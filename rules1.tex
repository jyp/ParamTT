%\documentclass[12pt,a4paper]{amsart}
\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{url}

\usepackage{verbatim}
\usepackage{latexsym}
\usepackage{amssymb,amstext,amsmath}
\usepackage{mathpartir}

\newcommand\CSig[1]{\Sigma^{#1}}
\newcommand\linefun[3]{\langle #2,#3 \rangle^{#1}}
\newcommand\linepred[3]{[ #2,#3 ]^{#1}}

\newcommand\myfrac[2]{
 \begin{array}{c}
 #1 \\
 \hline \hline 
 #2
\end{array}}

\newcommand{\UI}{{\bf I}}
\newcommand{\Ref}{{\sf Ref}}
\newcommand{\ID}{{\sf id}}
\newcommand{\JJ}{{\sf J}}
\newcommand{\HH}{{\sf H}}
\newcommand{\inh}{\mathsf{inh}}

\newcommand{\mkbox}[1]{\ensuremath{#1}}
\newcommand{\Id}{{\sf Id}}

\newcommand{\ideal}[1]{\langle #1\rangle}

\newcommand{\Idd}{{\sf Id}}
\newcommand{\CC}{{\mathcal C}}
\newcommand{\subst}{{\sf subst}}
\newcommand{\res}{{\sf res}}
\newcommand{\Int}{{\bf I}}
\newcommand{\sem}[1]{\langle #1\rangle}
\def\SET{{U}}

\newcommand{\Sph}{{\sf S}^1}
\newcommand{\pair}[1]{{\langle #1 \rangle}}
\newcommand{\Prod}[2]{\displaystyle\prod _{#1}~#2}
\newcommand{\Sum}[2]{\displaystyle\sum _{#1}~#2}
\newcommand{\gothic}{\mathfrak}
\newcommand{\omicron}{*}
\newcommand{\gP}{{\gothic p}}
\newcommand{\lift}[1]{\tilde{#1}}
\newcommand{\gM}{{\gothic M}}
\newcommand{\gN}{{\gothic N}}
\newcommand{\rats}{\mathbb{Q}}
\newcommand{\ints}{\mathbb{Z}}

% \usepackage{isolatin1}
\usepackage{a4wide}
\usepackage{verbatim}
\usepackage{proof}
\usepackage{latexsym}
% \usepackage{stmaryrd}
\newcommand{\abs}[2]{\lambda #1 . #2}            % abstraction of #1 in #2
\usepackage{mytheorems}
%\newtheorem{proposition}[theorem]{Proposition}
\newcommand{\GG}{{\sf f}}
\newcommand{\ext}{{\sf ext}}

%\documentstyle{article}
\newcommand{\IF}[3]{{{\sf if}~#1~{\sf then}~#2~{\sf else}~#3}}
\newcommand{\TT}{{1}}
\newcommand{\FF}{{0}}
\newcommand{\lfpi}[3]{(\Pi #1{:}#2)#3}
\newcommand{\lflam}[2]{\lambda #1.#2}
\newcommand{\HA}{{\sf HA}}
\newcommand{\AC}{{\sf AC}}
\newcommand{\HAw}{\hbox{\sf{HA}$^{\omega}$}}
\newcommand{\EM}{\hbox{\sf{EM}}}
\newcommand{\DC}{\hbox{\sf{DC}}}
\newcommand{\BB}{\hbox{\sf{B}}}

\def\NN{\hbox{\sf N}}
\def\Type{\hbox{\sf Type}}
\def\Box{\hbox{\sf B}}
\def\PER{\hbox{\sf PER}}
\def\FUN{\Pi}
\def\ELEM{\hbox{\sf El}}
\def\GET{\hbox{\sf get}}
\def\TP{\hbox{\sf TP}}
\def\N0{\hbox{\sf N}_0}
\def\ZERO{\hbox{\sf zero}}
\def\SUCC{\hbox{S}}
\setlength{\oddsidemargin}{0in} % so, left margin is 1in
\setlength{\textwidth}{6.27in} % so, right margin is 1in
\setlength{\topmargin}{0in} % so, top margin is 1in
\setlength{\headheight}{0in}
\setlength{\headsep}{0in}
\setlength{\textheight}{9.19in} % so, foot margin is 1.5in
\setlength{\footskip}{.8in}

% Definition of \placetitle
% Want to do an alternative which takes arguments
% for the names, authors etc.

\newcommand{\lbr}{\lbrack\!\lbrack}
\newcommand{\rbr}{\rbrack\!\rbrack}
%\newcommand{\sem}[2] {\lbr #1 \rbr_{#2}}  % interpretation of the terms
\newcommand{\PAIR}[2] {{<}#1,#2{>}}  % interpretation of the terms
\newcommand{\add}{\mathsf{add}}
\newcommand{\app}{\mathsf{app}}
\newcommand{\APP}{\mathsf{APP}}
\newcommand{\BAPP}[2]{\mathsf{app}(#1,#2)}
\newcommand{\nat}{{N}}
\newcommand{\NNO}{\hbox{\sf N$_0$}}
\newcommand{\UU}{\hbox{\sf U}}
\newcommand{\VV}{\hbox{\sf V}}
\newcommand{\EXIT}{\mathsf{exit}}
\newcommand{\natrec}{\hbox{\sf{natrec}}}
\newcommand{\boolrec}{\hbox{\sf{boolrec}}}
\newcommand{\nil}{[]}
\newcommand{\cons}{\mathsf{cons}}
\newcommand{\lists}{\mathsf{list}}
\newcommand{\VEC}{\mathsf{vec}}
\newcommand{\reclist}{\mathsf{RecL}}
\newcommand{\vect}{\mathsf{vect}}
\newcommand{\brec}{\Phi}
\newcommand{\brecp}{\Psi}
\newcommand{\case}{\mathsf{split}}
\newcommand{\true}{\mathsf{true}}
\newcommand{\false}{\mathsf{false}}
\newcommand{\bool}{{N_2}}
\newcommand{\ifte}[3]{\mathsf{if}\ #1\ \mathsf{then}\ #2\ \mathsf{else}\ #3}
\newcommand{\nats}{\mathbb{N}}
\newcommand{\Con}{{\sf Con}}
\newcommand{\Typ}{{\sf Type}}
\newcommand{\Elem}{{\sf Elem}}
\newcommand{\Char}{{\sf Char}}
%\newcommand{\id}{{\sf id}}
\newcommand{\id}{{1}}
\newcommand{\pp}{{\sf p}}
\newcommand{\qq}{{\sf q}}
\newcommand{\comp}{{\sf comp}}
% Marc's macros
\newcommand{\op}[1]{#1^\mathit{op}}
\newcommand{\set}[1]{\{#1\}} 
\newcommand{\es}{\emptyset}
\newcommand{\lto}{\longmapsto}
\newcommand{\rup}[1]{#1{\uparrow}}
\newcommand{\rdo}[1]{#1{\downarrow}}
\newcommand{\rupx}[1]{#1{\uparrow_{x}}}
\newcommand{\rdox}[1]{#1{\downarrow_{x}}}
\newcommand{\rupxy}[1]{#1{\uparrow_{x,y}}}
\newcommand{\rdoxy}[1]{#1{\downarrow_{x,y}}}
\newcommand{\rupyx}[1]{#1{\uparrow_{y,x}}}
\newcommand{\rdoyx}[1]{#1{\downarrow_{y,x}}}
\newcommand{\del}[1]{}
\newcommand{\ul}[1]{\underline{#1}}
%\newcommand{\bind}[2]{{\langle}#1.\, #2{\rangle}}
\newcommand{\bind}[2]{{\langle}#1{\rangle}#2}
\newcommand{\OO}{O}

% end Marc's macros

\input{unicodedefs}
\begin{document}

\title{A parametric Type theory}

\author{}
\date{\today}
\maketitle

\section*{Presheaf models of type theory}

 A group in a presheaf model over a category ${\cal C}$ can be seen as a functor
from ${\cal C}^{opp}$ to the category of groups.

 One way to present type theory is to use a generalized algebraic theory
with 4 sorts: contexts, types, terms and substitutions. Models of type theory
form then a category.

 If ${\cal C}$ is a category we define then a presheaf model over ${\cal C}$
to be a functory from ${\cal C}^{opp}$ to the category of models of type theory.
This notion can itself be expressed as a generalized algebraic theory, where each
of the sorts: contexts, types, terms and substitutions is now indexed by an object
of ${\cal C}$ and we add constants to express the functoriality laws.

\medskip

 One way to think of this is as a kind of ``non-standard'' extension of type theory.
The main application is that we can now add new constants expressing operations
that cannot be expressed in the standard version. The goal of this note is to provide
a concrete example of this phenomena, where we can formulate laws expressing an 
internal version of parametricity.

\section{A special case}


 We consider the category which has for objects finite set of symbols
$I,J,\dots$ not containing $0$ and maps $f:I\rightarrow J$
are set-theoretic functions $f:I\rightarrow J\cup\{0\}$ such that 
$f(i) = f(j)$ implies $i=j$ whenever $f(i)$ and $f(j)$ are in $J$.
This can also be described as the category of partial bijection.
We use the notations $f,g,h,\dots$ for the maps of this category.
The associated presheaf category is
equivalent to the category of ``nominal restriction sets'' studied in
section 9.1 of the book \cite{pitts}.

 If $x$ is not in $I$ we write $\iota_x:I\rightarrow I,x$ the canonical injection. 
The map $(x0):I,x\rightarrow I$ which sends $x$ to $0$ is a retraction of $\iota_x$.
It follows that $u\longmapsto u\iota_x$ is injective.
Any map $f$ can be written as a composition of ``elementary'' maps that are 
$(x0)$, setting $x$ to $0$, the maps $\iota_x$, and the maps $(xy)$, renaming
$x$ to a fresh variable $y$.

 We are going to describe presheaf models over the opposite of this category.

 We believe that this gives a semantics to the parametricity part of the work
on ``Type Theory in Colors'' \cite{BM}.


%\rightfooter{}

$$
\frac{\Gamma\vdash_I}{1:\Gamma\to_I \Gamma}~~~~~~~~
\frac{\sigma:\Delta\to_I\Gamma~~~~\delta:\Theta\to_I\Delta}
     {\sigma\delta:\Theta\to_I\Gamma}
$$
$$
\frac{\Gamma\vdash_I A~~~~~~\sigma:\Delta\to_I\Gamma}{\Delta\vdash_I A\sigma}~~~~~
\frac{\Gamma\vdash_I t:A~~~~~~\sigma:\Delta\to_I\Gamma}{\Delta\vdash_I t\sigma:A\sigma}~~~~~
$$
$$
\frac{}{()\vdash_I}~~~~~~
\frac{\Gamma\vdash_I~~~~~\Gamma\vdash_I A}{\Gamma.A\vdash_I}~~~~~~~~~~
\frac{\Gamma\vdash_I A}{\pp:\Gamma.A\to_I\Gamma}~~~~~~~~~
\frac{\Gamma\vdash_I A}{\Gamma.A\vdash_I \qq:A\pp}
$$
$$
\frac{\sigma:\Delta\to_I\Gamma~~~~\Gamma\vdash_I A~~~~~\Delta\vdash_I u:A\sigma}
     {(\sigma,u):\Delta\to_I\Gamma.A}~~~~~~~~
$$
$$
\frac{\Gamma.A\vdash_I B}{\Gamma\vdash_I\Pi~A~B}~~~~~~~~
\frac{\Gamma.A\vdash_I B~~~~\Gamma.A\vdash_I b:B}
     {\Gamma\vdash_I\lambda b:\Pi~A~B}
%\frac{\Gamma.A\vdash_I b:B}{\Gamma\vdash_I\lambda b:\Pi~A~B}
$$
$$
\frac{\Gamma\vdash_I w:\Pi~A~B~~~~~~\Gamma\vdash_I u:A}
     {\Gamma\vdash_I \app(w,u):B[u]}
$$

\medskip

The equations are

$$
{1\sigma = \sigma 1 = \sigma}~~~~~~{(\sigma\delta)\nu = \sigma(\delta\nu)}
$$
$$
A1 = A~~~~~~~~~~~~(A\sigma)\delta = A(\sigma\delta)~~~~~~~~~~
u1 = u~~~~~~~~~~~~(u\sigma)\delta = u(\sigma\delta)
$$
$$
{(\sigma,u)\delta = (\sigma\delta,u\delta)}~~~~~~{\pp (\sigma,u) = \sigma}~~~~~~~~~~~~{\qq(\sigma,u) = u}
$$
$$
(\Pi~A~B)\sigma = \Pi~(A\sigma)~(B(\sigma\pp,\qq))~~~~~~~~~~
$$
$$
     {\app(w,u)\delta= \app(w\delta,u\delta)}~~~~~~~~~~
     {\app(\lambda b,u)= b[u]}~~~~~~~~~~{w = \lambda (\app(w\pp,\qq))}~~~~~~~~~~{(\lambda b)\sigma = \lambda (b(\sigma\pp,\qq))}
$$
\medskip

 We have used the defined operation $[u] = (1,u)$

\medskip

 So far, this is like describing a collection of models, indexed by the objects $I$.
We add the new rules, the {\em restriction rules}, which connect these models
$$
\frac{\Gamma\vdash_I}{\Gamma f\vdash _J}~~~~~~~~~~
\frac{\Gamma\vdash_I A}{\Gamma f\vdash _J A f}~~~~~~~~~~~
\frac{\Gamma\vdash_I a:A}{\Gamma f\vdash _J af:Af}~~~~~~~~~~
\frac{\sigma:\Delta\rightarrow_I \Gamma}{\sigma f:\Delta f\rightarrow _J\Gamma f}
$$
for $f:I\rightarrow J$. We add also the equations which express that we have
a functor from the category of names to the category of models of type theory
$$
\Gamma 1 = \Gamma~~~~~~A 1 = A~~~~~~a1 = a~~~~~~~~~~(\Gamma f)g = \Gamma (fg)~~~~~~
(A f)g = A (fg)~~~~~~~~(af)g = a(fg)
$$
$$
\sigma 1 = \sigma~~~~(\sigma f) g = \sigma (fg)~~~~~~(\sigma\delta)f = \sigma f(\delta f)
$$
$$
(A\sigma) f = Af (\sigma f)~~~~~~~~(a\sigma)f = af (\sigma f)
$$
$$
(\sigma,u) f = \sigma f,uf~~~~~~~~\pp f = \pp ~~~~~~~~\qq f = \qq
$$
$$
(\Pi~A~B)f = \Pi~Af~Bf
$$
$$
(\lambda b) f = \lambda (bf)~~~~~~~~~\app(w,u)f = \app(wf,uf)
$$

\begin{theorem}
The rule
$$
\frac{\Gamma\vdash_I w:\Pi~A~B~~~~~~\Gamma\vdash_I u:A}{\Gamma\vdash_I \app(w,u):B[u]}
$$
is {\em equivalent} (modulo the other rules) to
$$
\frac{\Gamma\vdash_I w:\Pi~A~B~~~~~\Gamma f\vdash_J u:Af}{\Gamma f\vdash_J \app(wf,u):Bf[u]}{~~~~f:I\rightarrow J}
$$
\end{theorem}

\begin{proof}
Indeed, if we assume the first rule and we have $\Gamma\vdash_I w:\Pi~A~B$ and $f:I\rightarrow J$ then
we get $\Gamma\vdash_J wf:(\Pi~A~B)f$ by restriction. But we also have $(\Pi~A~B)f = \Pi~Af~Bf$ and if 
$\Gamma f \vdash_J u:Af$ then we get $\app(wf,u):Bf[u]$.

 Conversely, if we assume the second rule, in the special case where $I=J$ and $f = 1:I\rightarrow I$
we get the first rule since $A1 = A$ and $w1 = w$.
\end{proof}
\medskip

 If $\Gamma\vdash_I A$ we can think of $\Gamma$ as a context and $A$ as a type
dependent on some quantities represented by the symbols in $I$, quantities which 
may get the value $0$.

\medskip

 The maps $u\longmapsto u\iota_x$ are injective since $\iota_x(x0) = 1$.

 We {\em identify systematically} $\Gamma$ with $\Gamma\iota_x$ and $A$ with $A\iota_x$
and $a$ with $a\iota_x$ and $\sigma$ with $\sigma\iota_x$. In particular, we have
$\Gamma\vdash_{I,x} a:A$ if $\Gamma\vdash a:A$.

 If for instance $\Gamma\vdash_I A$ and $\Gamma\vdash_{I,x} u:A$ and there exists $a$
such that $\Gamma\vdash_I a :A$ and $u = a\iota_x = a$, we can express this by saying that
$a$ is {\em independent of} the symbol $x$.

\medskip

 If $\vdash_{x} A$ we think of $A$ as a {\em line} starting from the type $\vdash_{} A(x0)$.

\section{Transforming a predicate in a line}


 In order to internalize parametricity, we add the following ``non-standard" operations
$$
\frac{\Gamma\vdash_I A~~~~~~\Gamma\vdash_I P:A\rightarrow U}{\Gamma\vdash_{I,x} A\times_x P}~~~~~~~
\frac{\Gamma\vdash_I a:A~~~~~~\Gamma\vdash_I p:P~a}{\Gamma\vdash_{I,x} (a,_xp):A\times_x P}
$$
and
$$
\frac{\Gamma\vdash_{I,x} w:A\times_x P}{\Gamma\vdash_I w.x:P[w(x0)]}
$$
with the defining equations 
$$
(A\times_x P)(x0) = A~~~~~~~~~~(a,_x p)(x0) = a~~~~~~~(a,_x p).x = p
$$
and
$$
(A\times_x P) (xz) = A\times_z P~~~~~~~~(a,_xp)(xz) = a,_z p
$$
and
$$
(w.x)(yz) = (w(yz)).x~~~~~~~~~~(w.x)(yx) = (w(xz)(yx)).z
$$

 The operation $A\times_x P$ transforms a {\em predicate} over the type $A$ to a {\em line}
starting from $A$. This is similar (but much simpler) to the univalence axiom, which transforms
an equivalence between two types in a line joining these types.

\medskip

 We notice that the type $A\times_x P$ behaves like a {\em telescope} (in deBruijn's terminology).
If we have $t:A\times_x P \rightarrow B\times_x Q$ then $t(x0):A\rightarrow B$
and if $u:A,~p:P~u$ then $(t~(u,_xp)).x:Q~(t(x0)~u)$. So a term of type
 $t:A\times_x P \rightarrow B\times_x Q$ defines an element in
$(\Sigma f:A\rightarrow B)(\Pi u:A)P~u\rightarrow Q~(f~u)$.

\medskip

 With these rules, we can internalize parametricity. For instance, using a notation with names
for context, we can build a term of type $P~(f~A~a)$ in the context
$$
f:(\Pi X:U)X\rightarrow X,A:U,P:A\rightarrow U,a:A,b:P~a
$$
namely the term $(f~(A\times _x P)~(a,_x b)).x$ where $x$ is a fresh symbol. Indeed we have
$$(f~(A\times _x P)~(a,_x b))(x0) = f(x0)~(A\times_x P)(x0)~(a,_xb)(x0) = f~A~a$$
In this way, we have a ``non-standard''
proof of $P~(f~A~x)$. Notice that there is no ``standard'' proof of $P~(f~A~x)$ in this context.

\medskip

 Another example is
$$
L = (\Pi X:U)X\rightarrow (X\times_x A\rightarrow X)\rightarrow X
$$
which is such that
$$
L(x0) = N = (\Pi X:U)X\rightarrow (X\rightarrow X)\rightarrow X
$$
Notice that the type $L$ is a possible type for lists of elements in $A$ while
$N$ is the type of Church numerals. For instance if $a_0~a_1:A$ then
$$\lambda X\lambda a\lambda f~~f~(f~(a,_x a_0),_x a_1)$$
is an element $l:L$ representing the list $[a_0,a_1]$ and such that
$$l(x0) = \lambda X\lambda a\lambda f~~f~(f~a)$$

\section{Semantics}

 A context $\Gamma\vdash_I$ is interpreted
by a family of sets $\Gamma f$ for $f:I\rightarrow J$ with restriction maps
$\Gamma f\rightarrow \Gamma fg,~\rho\longmapsto \rho g$ satisfying $\rho 1 = \rho$
and $(\rho  g) h = \rho (gh)$. A type $\Gamma\vdash_I A$ is interpreted by giving
for each $f:I\rightarrow J$ and $\rho$ in $\Gamma f$ a set $A(f,\rho)$ with restriction
maps $A(f,\rho)\rightarrow A(fg,\rho g),~u\longmapsto u g$ satisfying $u1 = u$ and $(ug) h = u(gh)$.
The judgement $\Gamma\vdash _I a:A$ is interpreted by giving a family $a(f,\rho)$ in $A(f,\rho)$ such
that $(a(f,\rho))g = a(fg,\rho g)$. Finally a substitution $\sigma :\Delta\rightarrow_I \Gamma$
is interpreted by giving a family of maps $\sigma:\Delta f\rightarrow \Gamma f$ such that
$(\sigma\rho) g = \sigma (\rho g)$.

\medskip

 In particular here is the interpretation of the rule $\Gamma\vdash_{I,x} A\times_x P$
assuming $\Gamma\vdash_I,~\Gamma\vdash_I A,~\Gamma\vdash_I P:A\rightarrow U$.
Given $f:I,x\rightarrow J$ and $\rho$ in the set $\Gamma \iota_x f$, we have to define
a set $(A\times_x P)(f,\rho)$. The definition is by case whether or not $f(x) = 0$ or not.

 If $f(x) = 0$ then we define $(A\times_x P)(f,\rho) = A(\iota_x f,\rho)$.

 If $f(x) = y$ then we define $(A\times_x P)(f,\rho)$ to be the set of pairs
$(u,v)$ with $u$ in $A(\iota_x f(y0),\rho(y0))$ and $v$ in $P(\iota_xf(y0),\rho(y0))(u)$. We use that $\rho(y0)$
is in the set $\Gamma\iota_x f (y0)$.

\medskip
 
 A similar interpretation holds for $\Gamma\vdash_{I,x} (a,_x p):A\times_x P$.
Given $f:I,x\rightarrow J$ and $\rho$ in the set $\Gamma \iota_x f$, we have to define
$(a,_x p)(f,\rho)$ which should be an element of the set $(A\times_x P)\rho$. 
The definition is by case whether or not $f(x) = 0$ or not.

 If $f(x) = 0$ then we define $(a,_xp)(f,\rho)$ to be $a(\iota_xf,\rho)$.

 If $f(x) = y$ then we define $(a,_x p)(f,\rho)$ to be the pair $a(\iota_xf(y0),\rho(y0)),p(\iota_xf(y0),\rho(y0))$.

\medskip

 We justify the rule $\Gamma\vdash_I w.x:P~(w(x0))$ for $\Gamma\vdash_I$
and $\Gamma\iota_x\vdash_{I,x} w:A\times_x P$. We take $g:I\rightarrow J$ and
$\rho$ in the set $\Gamma g$ and we have to define $(w.x)(g,\rho)$.
We choose $y$ not in $J$ and define $(g,x=y):I,x\rightarrow J,y$.
We have $\rho\iota_y$ in the set $\Gamma\iota_x (g,x=y)$ since
$\iota_x (g,x=y) = g\iota_y$. The element $w(\iota_x (g,x=y),\rho\iota_y)$ is of the form
$u,v$ and we define $(w.x)(g,\rho) = v$.

\medskip

 We justify the rule $\Gamma.A\vdash_I$ if $\Gamma\vdash_I A$. For this we take
$f:I\rightarrow J$ and we have to define a set $(\Gamma.A)f$. We define this to be
the set of pairs $\rho,u$ with $\rho$ in $\Gamma f$ and $u$ in $A\rho$.
If $g:J\rightarrow K$ we define $(\rho,u)g = \rho g,ug$.

 We define next $\Gamma\vdash_I \Pi~A~B$ if $\Gamma.A\vdash_I B$. Given $f:I\rightarrow J$
and $\rho$ in $\Gamma f$ we define $(\Pi~A~B)\rho$ to be the set of families
$wg$ with $g:J\rightarrow K$ such that
$$
wg\in \Prod{u\in A\rho g}{B(\rho g,u)}
$$
and $(wg(u))h = w(gh)(uh)$ if $h:K\rightarrow L$.

 If $\Gamma.A\vdash _I b:B$ we can then define the interpretation of
$\Gamma\vdash_I \lambda b:\Pi~A~B$. Given $f:I\rightarrow J$ and
$\rho$ in $\Gamma f$ and $g:J\rightarrow L$ and $u$ in $A\rho g$ we define 
$$
(\lambda b)(f,\rho) g(u) = b(fg,(\rho g,u))
$$
since we have $(\rho g,u)$ in $(\Gamma.A)fg$.

\section{Special Rules}



Predicate over line. 
\inferrule{Γ ⊢_I Q : A → U\\Γ ⊢_I R : (x:A) → P x → Q x → U}
          {Γ ⊢_{I,i} \linepred i Q R : \CSig i A P → U}

(The predicate Q is necessary to make the above projectible)

Function over line:
\inferrule{Γ ⊢_I f : A → B\\Γ ⊢_I g : (x:A) → P x → Q (f x)}
          {Γ ⊢_{I,i} \linefun i f g : \CSig i A P → \CSig i B Q }


Application: the above can be used to construct a square type:

\inferrule{A : U \\ P,Q : A → U \\ R : (x:A) → Px → Qx → U}
          {\CSig j {(\CSig i A P)} \linepred i Q R}

We cannot even inhabit the square type, because we have nothing of type:

$(x : \CSig i A P) → \linepred i Q R x$

We cannot construct a cube type, because we cannot construct a relation like this:

$(x : \CSig i A P) → \linepred i Q R x → U$

\section{Inductive definition of param}

predicates. 
\begin{align*}
  U.i T &= T → U \\
  ((x:A) → B x).i f &= (x:A) → (x' : A.i x) → (B (x,_i x')).i (f x) \\
  (\CSig i A P).j (x,_i p) &= \CSig i (A.j x) (λq → P.j x q p) & \text{!!! swap}
  % (A,i P).j x  &= a.j x & \text{$p$ says only $a$ is well-formed.}
\end{align*}

evaluation of values
\begin{align*}
  f.i a p &= (f (a,_i p)).i \\
  (a,_i p).j  &= a.j ,_i p.j 
\end{align*}

To use with the typings:
\begin{mathpar}
\inferrule{Γ ⊢_I a : T i0 \\Γ ⊢_I p : T.i a}{Γ ⊢_{I,i} (a,_i p) : T}

\inferrule{Γ ⊢_I \\Γ ⊢_{I,i} a : T}{Γ ⊢_I a.i : T.i a (i0)}
\end{mathpar}

\section{The unit interval}
 
 We can introduce a non-standard type $\UI$ with the rules
$$
\frac{\Gamma\vdash_I}{\Gamma\vdash_I \UI}~~~~~~~~~\frac{\Gamma\vdash_I}{\Gamma\vdash_I 0:\UI}~~~~~~~~~
\frac{\Gamma\vdash_I}{\Gamma\vdash_I x:\UI}~{x\in I}
$$
and the equalities
$$
\UI f = \UI~~~~~~~~0f = 0~~~~~~~~~~x(y0) = x~~~~~~~~x(x0) = 0~~~~~~~~x(xy) = y~~~~~~~~x(yz) = x
$$



\section{Nominal presentation}

 We have defined a {\em family} of models $M_I$ connected by homomorphisms.
We can associate to this {\em one} model $M^*$. An object of $M^*$ (which can
be a context, or a type, or a term, or a substitution) is a pair $(I,u)$
where $I$ is a finite set of symbols and $u$ an object of $M_I$. We identify
$(I,u)$ and $(J,v)$ if $u$ and $v$ become equal in $M_{I\cup J}$.

\medskip

 Intuitively an object $v$ of $M^*$ depends on finitely many symbols. We can 
define the independence relation $x\#v$ to mean that $v = (I,u)$ for some $I$
not containing the symbol $x$.
The model $M^*$ has an endomorphism $(x0)$ for each symbol $x$, and automorphisms
$(xy)$ for $x$ and $y$ distinct symbols.

\section{Type-checking}

 We write $A,B,\dots$ for type values and $u,v,\dots$ for values and $t,T,\dots$ for terms.
Type-checking is specified by two relations
$$
I,\rho,\Gamma\vdash t\Downarrow A~~~~~~~~~~~I,\rho,\Gamma\vdash t\Uparrow
$$
For the relation $I,\rho,\Gamma\vdash t\Downarrow A$ we have $I,\rho,\Gamma,t$ given and
$A$ is inferred. For the relation $I,\rho,\Gamma\vdash t\Uparrow$ we check that $t$ has
the right given type $A$.

 In these relations $\Gamma$ gives type values to variables, so $\Gamma$ is of the form
$x_1:A_1,\dots,x_n:A_n$ while $\rho$ gives values to variables and is of the form
$x_1 = u_1,\dots,x_n=u_n$. The first argument $I$ is a set of names/symbols
$i_1,\dots,i_m$. 

 If $I$ is a set of symbols we write $\ID_I:I\rightarrow I$ the corresponding identity function.

 We have an evaluation function $t~f~\rho$ which takes one term $t$ which has been type-checked
using $I$, one function $f:I\rightarrow J$ and one environment of $J$-values $\rho$, and which produces
a $J$-value.

 The rules are then
$$
\frac{x:A~in~\Gamma}{I,\rho,\Gamma\vdash x\Downarrow A}
$$
$$
\frac{I,\rho,\Gamma\vdash t_0\Downarrow\Pi~A~F~~~~~~~~~I,\rho,\Gamma\vdash t_1\Uparrow A}
     {I,\rho,\Gamma\vdash t_0~t_1\Downarrow F~(t_1~\ID_I~\rho)}
$$
$$
\frac{I,\rho,\Gamma\vdash t_0\Downarrow U.i~A~~~~~~~~~I,\rho,\Gamma\vdash t_1\Uparrow A}
     {I,\rho,\Gamma\vdash t_0~t_1\Downarrow U}
$$
$$
\frac{I,\rho,\Gamma\vdash t_0\Downarrow (\Pi~A~F).i~c~~~~~~~~~
      I,\rho,\Gamma\vdash t_1\Uparrow A(i0)~~~~~~~
      I,\rho,\Gamma\vdash t_2\Uparrow A.i~(t_1~\ID_I~\rho)}
     {I,\rho,\Gamma\vdash t_0~t_1~t_2\Downarrow F~(t_1~\ID_I~\rho,_i t_2~\ID_I~\rho)}
$$
$$
\frac{}{I,\rho,\Gamma\vdash U\Downarrow U}
$$
$$
\frac{I,(\rho,x=X(I)),\Gamma,x:A\vdash t:F~X(I)}{I,\rho,\Gamma\vdash \lambda x.t\Uparrow \Pi~A~F}
$$
$$
\frac{I,(\rho,x=X(I)),\Gamma,x:A\vdash t:U}{I,\rho,\Gamma\vdash \lambda x.t\Uparrow U.i~A}
$$
$$
\frac{I,(\rho,x=X(I),y=Y(I)),\Gamma,x:A(i0),y:A.i~X(I)\vdash t:(F~(X(I),_i Y(I)).i~(c~X(I))}
     {I,\rho,\Gamma\vdash \lambda x~y.t\Uparrow (\Pi~A~F).i~c}
$$
$$
\frac{(I,i),\rho,\Gamma\vdash t\Downarrow (A,_i P)}
     {I,\rho,\Gamma\vdash t.i\Downarrow P~((t~\ID_{I,i}~\rho)(i0))}
$$
$$
\frac{I,\rho,\Gamma\vdash t\Downarrow A~~~~~~~A = B}{I,\rho,\Gamma\vdash t\Uparrow B}
$$
$$
\frac{I,\rho,\Gamma\vdash T\Uparrow U~~~~~~~~I,(\rho,x=X(I)),\Gamma,x:T~\ID_I~\rho\vdash T'\Uparrow U}
     {I,\rho,\Gamma\vdash \Pi~T~(\lambda x.T')\Uparrow U}
$$
$$
\frac{I,\rho(i0),\Gamma(i0)\vdash t\Uparrow A(i0)~~~~~~~I,\rho(i0),\Gamma(i0)\vdash p\Uparrow A.i~(t~\ID_I~\rho(i0))}
     {(I,i),\rho,\Gamma\vdash (t,_i p)\Uparrow A}
$$

 The evaluation is defined by
$$
x~f~\rho = \rho(x)~~~~~~~(t'~t)~f~\rho = t'~f~\rho~(t~f~\rho)
$$
$$
(t,_i p)~f~\rho = t~(f-i)~\rho(j0),_j p~(f-i)~\rho(j0)
$$
if $f(i) = j$ and 
$$
(t,_i p)~f~\rho = t~(f-i)~\rho
$$
if $f(i) = 0$.

 We also have an application
$$
(\lambda x.t)~f~\rho~v = t~f~(\rho,x=v)
$$

 We have $(a,_i p).i = p$.



\begin{thebibliography}{9}

\bibitem{BCH}
M.Bezem, Th. Coquand and S. Huber.
\newblock{A model of type theory in cubical sets.}
\newblock{Preprint, 2013.}

\bibitem{BM}
J.P. Bernardy, G. Moulin.
\newblock{Type Theory in Color, internalizing parametricity and erasure in type theory, ICFP, 2013.}

\bibitem{pitts}
A. M. Pitts.
\newblock{{\rm Nominal Sets. Names and Symmetry in Computer Science.}}
\newblock{Cambridge Tracts in Theoretical Computer Science, 2013.}

\bibitem{Pitts}
A. M. Pitts.
\newblock{An Equivalent Presentation of the Bezem-Coquand-Huber
Category of Cubical Sets}. Manuscript, 17 September 2013.

\bibitem{Cartmell}
J. Cartmell.
\newblock{Generalised algebraic theories and contextual categories.}
\newblock{Ann. Pure Appl. Logic 32 (1986), no. 3, 209--243.}

\bibitem{Curien}
P.L. Curien.
\newblock{Substitutions up to isomorphisms.}
\newblock{Fundamenta Informaticae, Volume 19, 1993, p. 51-85.}

\bibitem{Dybjer}
P. Dybjer.
\newblock{Internal Type Theory.}
\newblock{in {\em Types for Programs and Proofs}, Springer, 1996.}

\end{thebibliography}

\end{document}     
                                                                                  
 
