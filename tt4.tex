\documentclass[english]{PaperTools/latex/entcs}
\usepackage{graphicx}
\sloppy

\graphicspath{{PaperTools/latex/}}
\usepackage[numbers]{natbib}
\usepackage[utf8]{inputenc}
\usepackage{stmaryrd}
\usepackage{amssymb,amstext,amsmath,amsthm}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage{fancyref}
\usepackage{todonotes}
\input{fancyrefs}
\usepackage{tikz}
\usetikzlibrary{arrows}

\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\newcommand\CC[4]{(#2,_{#1} #3)}
\newcommand\CP[3]{(#2,_{#1} #3)}
\newcommand\CTimes[2]{(#2) Ã—_{#1}}
\newcommand\SW[2]{\mathsf{SW}^{#1}_{#2}}
\newcommand\sw[2]{\mathsf{sw}^{#1}_{#2}}
\newcommand\dom{\mathsf{dom}}
\newcommand\param[1]{\!\cdot\!#1}
\newcommand\pvar[2]{{#1}^{(#2)}}
\newcommand\op[1]{âˆ‹_{#1}}
\newcommand\ip[3]{Î£^{#1} {#2}\,{#3}}
\newcommand\fp[3]{âŸ¨#2 ,_{#1} #3âŸ©}
\newcommand\mor[2]{({#1}\,{#2})}
\newcommand\proj[2]{{#2}\mor{#1}0}
\newcommand\projp[2]{\proj{#1}{(#2)}}

\newcommand\comment[1]{}
\input{unicodedefs}

\def\pI{\ensuremath{\mathbf{pI}}}
\def\fresh#1{\mathsf{fresh}(#1)}
\def\Hom#1#2{\mathbf{Hom}(#1,#2)}
\def\ie{\textit{i.e.}}
\def\eg{\textit{e.g.}}
\def\app#1#2{\mathsf{app}(#1,#2)}
\def\El#1{\mathrm{El}(#1)}
\def\opp{\mathrm{op}}

\newboolean{tikz}
\setboolean{tikz}{true} % XXX set to false to disable diagrams

\allowdisplaybreaks

\def\lastname{J-P. Bernardy, T. Coquand and G. Moulin}
\begin{document}
\begin{frontmatter}
  \title{A presheaf model of parametric type theory}
  \author{Jean-Philippe Bernardy}
  \author{Thierry Coquand}
  \author{Guilhem Moulin}
  \address{Chalmers University of Technology and University of Gothenburg \\
  \href{mailto:bernardy@chalmers.se,coquand@chalmers.se,mouling@chalmers.se}%
       {\textnormal\tt\{bernardy,coquand,mouling\}@chalmers.se}}
\begin{abstract}
  We propose a new type theory with internalized
  parametricity. Compared to previous similar proposals, this version
  comes with a denotational semantics which is a refinement of the
  standard presheaf semantics of dependent type theory. Further, this
  presheaf semantics is a refinement of the one used to interpret
  nominal sets with restrictions.  The present calculus is a candidate for the
  core of a proof assistant with internalized parametricity.
\end{abstract}
\begin{keyword}
  Parametricity, Presheaf semantics, Type theory
\end{keyword}
\end{frontmatter}

\section{Introduction}
\citet{reynolds_types_1983} proved a general \emph{abstraction theorem} (sometimes called
\emph{parametricity theorem}) about polymorphic functions. His argument is
about a set theoretic semantic.  As he stated it, {\em the underlying
  idea is that the meanings of an expression in ``related''
  environments will be ``related'' values}.  For instance, he proves
that if $t_X$ is a term of type $X â†’ X$ and if we consider two sets
$A_0$, $A_1$ and a relation $R âŠ† A_0 Ã— A_1$, then we have
$R([t_X]_{X=A_0}(a_0),[t_X]_{X=A_1}(a_1))$ whenever $R(a_0,a_1)$,
where $[t_X]_{X=A}$ denotes the meaning of the expression $t_X$ where
$X$ is interpreted by the set $A$. As he noted, one can replace in
this statement binary relations by $n$-ary relations, and in particular
unary relations (predicates). In the latter case, the statement is the following:
if $A$ is a set and $P$ is a predicate on $A$, then we have
$P([t_X]_{X=A}(a))$ whenever $P(a)$ holds.
\citet{wadler_theorems_1989} illustrates by many examples how this
result is useful for reasoning about functional programs.

The argument and result of Reynolds are model-theoretic in nature.
In lambda-calculi with dependent types, it is possible to state such an
abstraction result in a purely syntactical way.
One states for example that if a function $f$ has type
$(A : â˜…) â†’ â˜… â†’ â˜…$ --- the type of the polymorphic identity --- then the
following proposition holds:
$$ (A : â˜…) â†’ (P : A â†’ â˜…) â†’ (x : A) â†’ P\, x â†’ P (f\, A\, x) $$
%
Indeed \citet{bernardy_proofs_2012} prove such a result as a
(syntactical) meta-theorem about type systems. However this result is
not provable internally, \ie, the following is not provable:
$$ (f : (A:â˜…) â†’ A â†’ A) â†’  (A : â˜…) â†’ (P : A â†’ â˜…) â†’ (x : A) â†’ P\, x â†’ P (f\, A\, x) $$

As a workaround, users relying on the parametricity conditions have
postulated the parametricity axiom
\citep{pouillard_nameless_2011,chlipala_parametric_2008,atkey_unembedding_2009}.
However, %this approach has a fundamental drawback:
because such postulate does not have a computational interpretation,
parametricity conditions can only be used in computationally-irrelevant
positions.

Instead, one would like to be able to rely on parametricity conditions
within proof assistants themselves.  Several attempts have been made
\citep{bernardy_computational_2012,bernardy_type-theory_2013} --- or are currently
developed \citep{altenkirch2014syntax} ---
for designing an extension of dependent type theory in which such an internal form of
parametricity holds. We propose another such system here.
Our technical contributions are as follows:
\begin{itemize}
\item We present a type theory (\fref{sec:syntax}) which internalizes parametricity (as we show in \fref{sec:parametricity})
  and can be seen as a simplification and generalization of the systems of
  \citet{bernardy_computational_2012,bernardy_type-theory_2013}.
  In particular, given a $Î»$-term we have a special pairing construction
  to associate it to its parametricity proof, as well as special
  projections to isolate the proof. As seen in \fref{ex:poly-id}, these
  new constructions enable us to prove the above proposition
  \emph{internally}.  (This is not possible with usual pair and
  projections as the first projection does not commute with
  application.)  Furthermore we distinguish between multiple uses of the
  parametricity by naming (a.k.a \emph{coloring}) the pairs and
  projections; this is analogous to building hypercubes and accessing to
  their vertices as in \citep{bernardy_computational_2012}.
  However, unlike previous type theories with internalized parametricity
  \citep{bernardy_computational_2012, bernardy_type-theory_2013}, the
  system presented here does not allow computation of parametricity types:
  For instance, the parametricity predicated of $a : â˜…$ is
  \emph{isomorphic to} rather than convertible to $A â†’ â˜…$.  (As shown in
  \fref{sec:parametricity}, this does not seem to be an issue in
  practice.)
\item We provide a \emph{denotational} semantics, in the form of a presheaf model, for this type theory (\fref{sec:model}).
      This model is a refinement of the presheaf semantics used to
      interpret nominal sets with
      restrictions~\citep{bezem2014model,DBLP:journals/corr/Pitts14}.
\end{itemize}
We conjecture that conversion and type-checking are decidable for this system.

\section{Syntax}
\label{sec:syntax}
In this section we define the syntax and typing rules of our
parametric type theory, as well as the equality judgment.

We assume a special symbol â€˜0â€™, and a countable infinite set $ğ•€$ of
other symbols, called \emph{colors}.
The metasyntactic variables $i,j,\ldots$ range over colors,
while $Ï†$ range over $ğ•€ âˆª \{0\}$.
We further assume a fixed function $\fresh{Â·}$ such that
$\fresh{I} âˆˆ ğ•€ \backslash I$ for any finite color set $I$.
%
The main innovation of the type theory
presented here is that terms may depend on (a finite number of)
colors.
\begin{definition}[Syntax of terms and contexts]
  \begin{align*}
    A,B,P,T,a,b,p,t,u &
              \coloneqq x & \text {variable} \\
            & \mid U & \text{universe} \\ 
            & \mid |A| & \text{code} \\ 
            & \mid \El{A} & \text{decode} \\
            & \mid Î»x:A. b & \text{abstraction} \\
            & \mid tÂ u & \text{application} \\ 
            & \mid (x:A) â†’ B & \text{product} \\
            & \mid \CP i a p & \text{colored pair} \\
            & \mid \CTimes i {x:A} P & \text{colored type pair} \\
            & \mid \fp i t u & \text{colored function pair}\\
            & \mid A \op i a & \text{parametricity type} \\
            & \mid a \param i & \text{parametricity proof} \\
    \Gamma,\Delta & \coloneqq () \mid \Gamma,x:A \mid \Gamma,i:ğ•€
  \end{align*}
\end{definition}

We give a few intuitions to interpret the novel syntax, before giving formally the typing rules of the system. 
\begin{enumerate}
\item \citet{reynolds_types_1983} associates each type with a
  predicate. Here, each type is associated not a single predicate, but
  many: one for every color. (Using a new name for each application of
  Parametricity is analogous to naming dimensions in the hypercubes of
  our earlier syntax \citep{bernardy_computational_2012}; making a
  distincition between these dimensions solves the problem of
  swapping described in that paper.)
  Furthermore these predicates are definable
  in the logic: The type $A \op i a$ expresses that $a$ satisfies
  the parametricity predicate associated with the type $A$ on color~$i$.
\item The term $a \param i$ yields a proof of $A \op i \proj i a$, where
  $\proj i a$ denotes the realizer part of $a$,
  obtained by erasing the color $i$. (Erasure is detailed in
  \fref{def:color-erasure}.)
\item The forms $\CP i a p$, $\CTimes i {x:A} P$ and $\fp i t u$ allow to
  locally associate parametricity proofs with a given realizer.
\item Free colors appear in the context, and bound using the
  constructs $A \op i {}$ and $a \param$
\end{enumerate}



\begin{definition}[Typing judgements â€” Ã  la Tarski]~\\\indent
\fbox{$Î“âŠ¢$}
  \begin{mathpar}
    \inferrule[Empty]{~}{() âŠ¢ }

    \inferrule[NewVar]{Î“âŠ¢ \\ Î“ âŠ¢ A }{ Î“,x:A âŠ¢ }

    \inferrule[NewCol]{Î“âŠ¢ }{ Î“,i:ğ•€ âŠ¢ }
  \end{mathpar}
 
\fbox{$Î“âŠ¢ A$}
 \begin{mathpar}
    \inferrule[Universe]{~}{Î“ âŠ¢ U}

    \inferrule[Decode]{Î“ âŠ¢ A : U}{Î“ âŠ¢ \El{A}}

    \inferrule[Swap]{Î“, i:ğ•€, j:ğ•€, Î” âŠ¢ A}{Î“, j:ğ•€, i:ğ•€, Î”  âŠ¢ A}
 \end{mathpar}
 \begin{mathpar}
    \inferrule[Pi]{Î“ âŠ¢ A \\ Î“,x:A âŠ¢ B}{Î“ âŠ¢ (x:A) â†’ B}

    \inferrule[Out]{Î“, i:ğ•€ âŠ¢ A \\ Î“ âŠ¢ a : \proj i A}{Î“ âŠ¢ A \op i  a}

    \inferrule[In-Pred]{Î“ âŠ¢ A \\ Î“,x:A âŠ¢ P}{Î“, i:ğ•€ âŠ¢ \CTimes i {x:A} P}
 \end{mathpar}

\fbox{$Î“âŠ¢ a : A$}
  \begin{mathpar}
    \inferrule[Conv]{Î“ âŠ¢ t:A \\ A = B}{Î“ âŠ¢ t : B}

    \inferrule[Var]{Î“ âŠ¢ \\ x : A âˆˆ Î“}{Î“ âŠ¢ x : A}

    \inferrule[Code]{Î“ âŠ¢ A }{Î“ âŠ¢ |A| : U}

    \inferrule[Swap]{Î“, i:ğ•€, j:ğ•€, Î” âŠ¢ a : A}{Î“, j:ğ•€, i:ğ•€, Î”  âŠ¢ a : A}
    \\
    \inferrule[Lam]{Î“,x:A âŠ¢ b : B}{Î“ âŠ¢ Î»x:A.b : (x:A) â†’ B}
 
    \inferrule[App]{Î“ âŠ¢ t : (x:A) â†’ B[x] \\ Î“ âŠ¢ u : A}{Î“ âŠ¢ tÂ u: B[u]}
    \\
    \inferrule[In-Abs]{Î“ âŠ¢ a : \proj i A \\Î“ âŠ¢ p : A \op i a}{Î“, i:ğ•€ âŠ¢ \CP i a p : A}

    \inferrule[In-Fun]
        {Î“ âŠ¢ t : \projp i {(x:A) â†’ P[x]}\\\\
         Î“ âŠ¢ u : (x:\proj i A) â†’ (x':A \op i x) â†’ P[\CP i x {x'}] \op i t x}
        {Î“, i:ğ•€ âŠ¢ \fp i t u : (x:A) â†’ P[x]}

    \inferrule[Color-Elim]{Î“, i:ğ•€ âŠ¢ a : A}{Î“ âŠ¢ a \param i : A \op i {\proj i a}}
  \end{mathpar}
\end{definition}

The parametricity constructions ($Â·$ and $âˆ‹$) act like color
binders (they bring colors into scope), while the pairing constructs
remove colors from scope.
The equality relation used in the {\sc Conv} rule is detailed below in
\fref{def:conversion}.  The \textsc{Swap} rules allow us to use
\textsc{Out} and \textsc{Color-Elim} with any free color, provided that
no variable vas introduced after that color (see \eg, \fref{thm:param-2-sym}).

Additionally, for the above system to be well-founded, we need to
distinguish small and big types, and allow only small types to be
encoded in $U$. Small types are closed under product, $Ã—_i$ and
$âˆ‹_i$. The distinction between big and small types being standard, and
to keep the presentation concise, we leave it implicit in the syntax.

\begin{definition}[Color renaming and erasure]~
  \label{def:color-erasure}
  We consider a color $i âˆˆ ğ•€$ and some $Ï† âˆˆ ğ•€ âˆª \{0\}$,
  and define the term $a(i\,Ï†)$ by induction on $a$.
\begin{align*}
  x \mor{i}{Ï†} & = x \\
  U \mor{i}{Ï†} & = U \\
  \El{A} \mor{i}{Ï†} & = \El {A\mor{i}{Ï†}} \\
  |A| \mor{i}{Ï†} & = |A\mor{i}{Ï†}| \\
  (Î»(x:A).b)\mor{i}{Ï†} &= Î»(x:A\mor{i}{Ï†}).b\mor{i}{Ï†} \\
  (t\,u)\mor{i}{Ï†} &= (t\mor{i}{Ï†}) \, (u\mor{i}{Ï†}) \\
  ((x:A)â†’B)\mor{i}{Ï†} &= (x:A\mor{i}{Ï†})â†’(B\mor{i}{Ï†}) \\
  {\CP {i} a p}\mor{i}{0} &= a \\
  {\CP {i} a p}\mor{i}{j} &= \CP {j} a p \\
  {\CP {i} a p}\mor{j}{Ï†} &= \CP {i} {a\mor{j}{Ï†}} {p\mor{j}{Ï†}} &\text{if $i â‰  j$} \\
  (\CTimes {i} {x:A} P)\mor{i}{0} &= A \\
  (\CTimes {i} {x:A} P)\mor{i}{j} &= \CTimes {j} {x:A} P \\
  (\CTimes {i} {x:A} P)\mor{j}{Ï†} &= \CTimes {i} {x:A\mor{j}{Ï†}} {P\mor{j}{Ï†}} &\text{if $i â‰  j$} \\
  {\fp {i} t u}\mor{i}{0} &= t \\
  {\fp {i} t u}\mor{i}{j} &= \fp {j} t u \\
  {\fp {i} t u}\mor{j}{Ï†} &= \fp {i} {t\mor{j}{Ï†}} {u\mor{j}{Ï†}} &\text{if $i â‰  j$} \\
  (A \op {i} a)\mor{i}{Ï†} &= {A\mor{i}{j}\mor{i}{Ï†}} \op {j} {a\mor{i}{Ï†}} &\text{where $j = \fresh{\{i\}}$} \\
  (A \op {i} a)\mor{j}{Ï†} &= (A\mor{j}{Ï†}) \op {i} (a\mor{j}{Ï†}) &\text{if $i â‰  j$} \\
%
  (a Â· i)\mor{i}{Ï†} &= a \mor{i}{j}\mor{i}{Ï†} Â· j &\text{where $j = \fresh{\{i\}}$} \\
  (a Â· i)\mor{j}{Ï†} &= a\mor{j}{Ï†} Â· i &\text{if $i â‰  j$} \\
  \end{align*}
\end{definition}

\begin{theorem}[Color erasure and substitution preserve typing]
  If $Î“,i:ğ•€  âŠ¢ a : A$ then the terms $a(i\,Ï†)$ and $A(i\,Ï†)$ are
  defined and
  \begin{itemize}
    \item $Î“ âŠ¢ a(i\,0) : A(i\,0)$, and
    \item $Î“, j :ğ•€ âŠ¢ a(i\,j) : A(i\,j)$.
  \end{itemize}
\end{theorem}
\begin{proof}
  By induction on the typing judgment.
\end{proof}

\comment{
\begin{definition}[Normal forms and neutral terms]~
  \begin{align*}
    \mathsf{Nf} âˆ‹ u,v,A,B & \coloneqq
      U \mid Î»x:A. t \mid (x:A) â†’ B \\
      & \mid \CP i u v \mid \fp i u v \\
      & \mid {(\CTimes {iâ‚€} A B)} \op {iâ‚} {u_1 \cdots} \op {i_n} {u_n} &\quad \text{($iâ‚€ \prec iâ‚ \prec \ldots \prec i_n$)} \\
      & \mid s \param {iâ‚€} \cdots \param {i_{n-1}}                  &\quad \text{($iâ‚€ \prec   < \ldots \prec i_{n-1}$)}
    \\
    \mathsf{Ne} âˆ‹ s & \coloneqq x \mid s \, u
  \end{align*}
\end{definition}
}

\begin{definition}[Conversion]
\label{def:conversion}
The convertibility of types used in the {\sc Conv} rule and written
simply ($=$) is defined as the smallest congruence containing the
following rules.
\begin{mathpar}
  \inferrule[Pair-Param]{}{{(a,_i p)}\param i   = p}
\and
  \inferrule[Pair-App]{}{{\fp i t u} \, a      = (t\,{\proj i a} ,_i u\,{\proj i a}\,{(a \param i)})}
\and
  \inferrule[Pair-Pred]{}{{(\CTimes i {x:A} P[x])} \op i a = P[a]}
    \\
    %\inferrule[Surj-Param]{\proj i t = a \\ t \param i = p} {t = \CP i a p }
    \inferrule[Surj-Param]{} {t = \CP i {\proj i t} {t \param i} }
    \and
    %\inferrule[Surj-Fun]{\proj i t = u \\ (t \CP i x y) \param i = v x y} {t = \fp i u v }
    \inferrule[Surj-Fun]{} {t = \fp i {\proj i t} {Î»x x'. (t \CP i x {x'}) \param i}}
    \and
    %\inferrule[Surj-Typ]{\proj i T = A \\ T \op i x = B} {T = \CTimes i {x:A} B }
    \inferrule[Surj-Typ]{} {T = \CTimes i {x:{\proj i T}} {(T \op i x)} }
    \\
    \inferrule{}{\El{|A|} = A}
\and
    \inferrule{}{|\El{A}| = A}
\and
    \inferrule[Î²]{}{(Î»x:A. b[x]) u = b[u]}
\and
    \inferrule[Î·]{tÂ x = b} {t = Î» x:A.b}
    \\
    \inferrule[Refl]{~}{a = a}
    \and
    \inferrule[Sym]{a = b}{b = a}
    \and
    \inferrule[Trans]{a = b \\ b = c}{a = c}
  \end{mathpar}
\end{definition}

\begin{remark}
  In order to be well-typed the context of the conclusion of the
  \textsc{Pair-App}, \textsc{Surj-Param}, \textsc{Surj-Fun} and
  \textsc{Surj-Typ} needs to end with the color binding $i : ğ•€$.
\end{remark}

%\begin{corollary}[Any term can be seen as a pair of a realizer and a parametricity proof]
%  \label{cor:equalities}
%  In a context ending with $i : ğ•€$,
%  \begin{itemize}
%  \item $t = \CP i {\proj i t} {t \param i}$
%  \item $T = \CTimes i {x:\proj i T} {(T \op i x)}$
%  \item $t = \fp i {\proj i t} {Î»x x'. (t \CP i x {x'}) \param i}$
%  \end{itemize}
%\end{corollary}

Our conversion relation is intentional for functions, but extensional
when it comes to dependencies on colors. Because there is at any point
only a finite number of colors to consider, we conjecture that our
conversion relation is decidable.

\section{Parametricity}
\label{sec:parametricity}
%\todo{more examples: any $f : U â†’ Bool$ is constant,â€¦}
In this section we prove that our system properly internalizes
parametricity. We also illustrate the system by giving a few simple
proofs relying on parametricity (including iterated parametricity).

Unlike previous type theories with internalized parametricity
\citep{bernardy_computational_2012, bernardy_type-theory_2013}, the
system presented here lacks equalities which allow to compute
parametricity types. Expressed in our syntax, those equalities would
become the conversion rules:
\begin{center}$U \op i A = A â†’ U$, and\end{center}
\begin{center}$((x:A) â†’ B[x]) \op i f = (x:A) â†’ (x' : A \op i x) â†’ B[\CP i x {x'}] \op i (f x).$\end{center}

The absence of the above equalities allows for a simpler system, but
how can we ensure that all parametricity theorems hold?  The answer is
that the above relationships hold as isomorphisms.
%
We say that $A$ is \emph{isomorphic to} $B$ iff.
\begin{enumerate}
  \item There exist $f : A â†’ B$,
  \item There exist $g : B â†’ A$,
  \item For any $x$, $f\, (g\, x) = x$, and
  \item For any $x$, $g\, (f\, x) = x$.
\end{enumerate}
This notion of isomorphism is quite strong, because the equality used
in its definition is the conversion relation (\fref{def:conversion}).

\begin{theorem}
\label{thm:iso-univ}
$U \op i A$ is isomorphic to $A â†’ U$.
\end{theorem}
\begin{proof}~
  \begin{enumerate}
  \item
    $\begin{array}[t]{l@{\,}l}
      f &: (Q : U \op i A) â†’ A â†’ U \\ 
      f & Q\, x = \CP i A Q \op i x
    \end{array}$
  \item
    $\begin{array}[t]{r@{\,}l}
      g &: (P : A â†’ U) â†’ U \op i A\\
      g &P = (\CTimes i {x:A} (P x)) \param i
    \end{array}$
  \item $\CP i A {(\CTimes i {y:A} (P y)) \param i} \op i x = (\CTimes i {y:A} (P y)) \op i x = P x$
    by \textsc{Pair-Param} then \textsc{Pair-Pred}, and we conclude by
    $Î·$-contraction.
  \item $(\CTimes i {x:A} {\CP i A Q \op i x}) \param i = {\CP i A Q} \param i = Q$
    by \textsc{Surj-Typ} (indeed $\CTimes i {x:A} {\CP i A Q \op i x}$
    is typed in a context ending with $i:ğ•€$) and \textsc{Pair-Pred}.
  \qedhere
  \end{enumerate}
\end{proof}

\begin{theorem}
\label{thm:iso-fun}
$((x:A) â†’ B[x]) \op i f$ is isomorphic to $$(x:A) â†’ (x' : A \op i x) â†’ B[\CP i x {x'}] \op i {(f\, x)}$$
\end{theorem}
\begin{proof}~
  \begin{enumerate}
  \item $\begin{array}[t]{r@{\,}l}
      f &: (q : ((x:A) â†’ B[x]) \op i f) â†’ (x:A) â†’ (x' : A \op i x) â†’ B[\CP i x {x'}] \op i {(f x)}\\
      f &q\, x\, x' = (\CP i f q \CP i x {x'}) \param i
    \end{array}$
  \item $\begin{array}[t]{r@{\,}l}
      g &: ((x:A) â†’ (x' : A \op i x) â†’ B[\CP i x {x'}] \op i (f\,x)) â†’  ((x:A) â†’ B[x]) \op i f\\
      g & p= \fp i f p \param i
    \end{array}$
  \item $(\CP i f {\fp i f p \param i}\, \CP i x x') \param i
      = ({\fp i f p}\, \CP i x {x'}) \param i
      = \CP i {f\, x} {p\, x\, x'} \param i
      = p\, x\, x'$
    by \textsc{Surj-Param}
    then \textsc{Pair-App}
    (indeed $\fp i f p$ and ${\fp i f p}\, \CP i x {x'}$ are typed in a
    context ending with $i:ğ•€$)
    and we conclude by \textsc{Pair-Param}.

  \item $\fp i f {Î»x x'. (\CP i f q\, \CP i x {x'}) \param i} \param i
      = {\CP i f q} \param i
      = q$
    by \textsc{Surj-Fun}
    (indeed $\CP i f q$ is typed in a context ending with $i:ğ•€$)
    and we conclude by \textsc{Pair-Param}.
  \qedhere
  \end{enumerate}
\end{proof}

In practice, when carrying out parametricity proofs, many of the steps
of the above isomorphisms cancel each other and one obtains a simpler
proof. This behaviour is illustrated by the following example:
parametricity for the polymorphic identity and Church-encoded natural numbers.
(For the sake of simplicity, in the remainder of this section, we leave out the
distinction between types and their codes.)

\begin{example}
  \label{ex:poly-id}
  Any function $f : (X : U) â†’ X â†’ X$ is the polymorphic identity, \ie,
  its output is Leibniz-equal to its second argument. Assume a context
  $$Î“ = f : (X : U) â†’ X â†’ X,\enspace
    A : U,\enspace
    P : A â†’ U,\enspace
    a : A,\enspace
    p : P\, A$$
  Then
  $Î“, i:ğ•€âŠ¢\CTimes i {x:A} {(P\,x)}$
  and by \textsc{Pair-Pred}
  %(because $Î“ âŠ¢ (\CTimes i {x:A} {(P\,x)}) \op i a = P\,a$)
  $Î“, i:ğ•€âŠ¢\CP i a p : \CTimes i {x:A} {(P\,x)}$, thus
  $Î“, i:ğ•€âŠ¢f\, (\CTimes i {x:A} {(P\,x)})\, {\CP i a p} : \CTimes i {x:A} {(P\,x)}$
  and finally
  \begin{align*}
   Î“ âŠ¢(f\, (\CTimes i {x:A} {(P\,x)})\, {\CP i a p}) \param i
   &: (\CTimes i {x:A} {(P\,x)}) \op i \proj i {(f\, (\CTimes i {x:A} {(P\,x)})\, {\CP i a p})} \\
   &= P\, \proj i {(f\, (\CTimes i {x:A} {(P\,x)})\, {\CP i a p})}
    = P\, (f\, A\, a)
  \end{align*}
\end{example}

\begin{example}
  \label{ex:church-nat}
Let $N = (X : U) â†’ X â†’ (X â†’ X) â†’ X$.
Proving (unary) parametricity for $N$ means that, assuming a context $Î“$
  $$f : N,\enspace
    A : U,\enspace
    P : A â†’ U,\enspace
    z : A,\enspace
    z' : P\, z,\enspace
    s : A â†’ A,\enspace
    s' : (x:A) â†’ P\, x â†’ P\, (s\, x),$$
we can prove $P\, (f\, A\, z\, s)$.

Indeed
  $Î“, i:ğ•€âŠ¢\CTimes i {x:A} {(P\,x)}$,
  and by \textsc{Pair-Pred}
  $Î“, i:ğ•€âŠ¢ \CP i z {z'} : \CTimes i {x:A} {(P\,x)}$ and
  $Î“, i:ğ•€âŠ¢ \fp i s {s'} : \CTimes i {x:A} {(P\,x)} â†’ \CTimes i {x:A} {(P\,x)}$,
thus
  \begin{align*}
    &Î“, i:ğ•€ âŠ¢ f\, (\CTimes i {x:A} {(P\,x)})\, {\CP i z {z'}}\, \fp i s {s'} : \CTimes i {x:A} {(P\,x)}\text{, and finally}\\
    &Î“ âŠ¢ (f\, (\CTimes i {x:A} {(P\,x)})\, {\CP i z {z'}}\, \fp i s {s'}) \param i
       : (\CTimes i {x:A} {(P\,x)}) \op i (f\, A\, z\, s)
       = P\, (f\, A\, z\, s)
  \end{align*}
\end{example}

As seen in \fref{ex:church-nat}, one needs to use the
$\fp i t u$ to pair a function with the parametricity proof of its type
if one wants to apply that pair to some argument and reduce the
application.  This is because as noted above, our system does not
support direct computation of free theorems: in particular $(A â†’ B) \op i a$
does not reduce.

At this point one may wonder, since a new syntactic construction was
introduced for function types, if yet another construction is required
for higher order functions.  It turns out $\fp i t u$ can be combined
with $\CP i a p$ to pair higher order functions with the parametricity
proof of their type, as illustrated in the following example.

\begin{example}
  Let $F = (X : U) â†’ ((X â†’ X) â†’ X) â†’ X$.
  Proving (unary) parametricity for $F$ means that, assuming a context
  %\begin{multline*}
    $Î“ = f : F,\enspace
    A : U,\enspace
    P : A â†’ U,\enspace
    g : (A â†’ A) â†’ A,\enspace
    g' : (h : A â†’ A) â†’ ((x : A) â†’ P\, x â†’ P\, (h\, x)) â†’ P\, (g\, h)$,
  %\end{multline*}
  we can prove $P\, (f\, A\, g)$.

  Let $T = \CTimes i {x:A} {(P\,x)}$.
%  and $Î” = Î“, h:A â†’ A, h': (T â†’ T) \op i h$.
  We have $Î“, i:ğ•€ âŠ¢ T$ and
  \begin{align*}
    \!\!\!&Î“, h:A â†’ A, h': (T â†’ T) \op i h, x : A, x' : P\, x, i:ğ•€ âŠ¢ \CP i h {h'} : T â†’ T\text{, hence}
    \\
    \!\!\!&Î“, h:A â†’ A, h': (T â†’ T) \op i h, x : A, x' : P\, x âŠ¢ (\CP i h {h'}\, \CP i x {x'}) \param i : T \op i h\, x = P\, (h\, x)
    \\
    \!\!\!&Î“, h:A â†’ A, h': (T â†’ T) \op i h âŠ¢ g'\, h\, (Î» (x : A).\, Î» (x' : P\, x).\, (\CP i h {h'}\, \CP i x {x'}) \param i) : P\, (g\, h)
  \end{align*}
  Let $g'' = Î» h.\, Î» h'.\, g'\, h\, Î» (x : A).\, Î» (x' : P\, x).\, (\CP i h {h'}\, \CP i x {x'}) \param i$.
  Since we have $Î“ âŠ¢ g'' : (h:A â†’ A) â†’ (T â†’ T) \op i h â†’ P\, (g\, h)$
  we can pair it with $g$ and
  $Î“, i:ğ•€ âŠ¢ \fp i g {g''} : (T â†’ T) â†’ T$. We can finally conclude as before, that
  $Î“ âŠ¢ (f\, T\, \fp i g {g''}) \param i : P\, (f\, A\, g)$.
\end{example}

\subsection{Iterating Parametricity}
In our system, one can use parametricity generically as follows:
\begin{align*}
p &: (X:U) â†’ (x:X) â†’ X \op i x\\
p\, X\, x &= x\param i
\end{align*}
We have already seen that $A \op i $ corresponds to the parametricity
predicate for type $A$.
As we hinted at in the introduction, the color index $i$ allows us to
distinguish each application of Parametricity.  (As a side remark, since
the \textsc{Param} rules ``consumes'' a color, limiting nested
applications of Parametricity can trivialy be enforced in our system by
limiting the number of free colors in the context.)
We can iterate the operator $A \op {Â·} $ to construct
relations between parametricity witnesses. That is, given a context with
$$x :A,\enspace
  y : A \op j x,\enspace
  z : A \op i x,$$
the type $A \op i \CP j x y \op j z$ is well formed ($âˆ‹$ is left
associative), and can be understood as a relation
between the parametricity proofs $y$ and $z$. The following results about this relation illustrate the expressivity of our system.
\begin{theorem}
  \label{thm:param-2-sym}
If the type $A$ does not depend on either $i$ or $j$, the relation $Î»y z. A \op i \CP j x y \op j z$ is symmetric.
\end{theorem}
\begin{proof}
  We first construct the proof term:
  \begin{align*}
    &\sigma_1 : (x:A) â†’ (y : A \op i x) â†’ (z : A \op i x) â†’ A \op i \CP j x y \op j z â†’ A \op j \CP i x z \op i y \\
    &\sigma_1\, x\, y\, z\, w = \CP i {\CP j x y}{\CP j z w} \param j \param i
  \end{align*}
  And, by Î±-equivalence on colors, $A \op j \CP i x z \op i y = A \op i \CP j x z \op j y$.
\end{proof}

\begin{theorem}
  The types $A \op i \CP j x y \op j z$ and $A \op j \CP i x z \op i y$ are isomorphic.
\end{theorem}
\begin{proof}
  We show that %the function $\sigma_1$ (defined above) is involutive in its last argument, \ie,
  $\sigma_1\, y\, x\, z\, (\sigma_1\, x\, y\, z\, w) = w$.
  Let
    $t = \CP i {\CP j x y}{\CP j z w},\enspace
    w' = t \param j \param i,\enspace
    t' = \CP j {\CP i x z}{\CP i y {w'}}.$
  Then
  $\proj i {t'} = \CP j x y = \proj i t$,
  $\proj j {t'} = \CP i x z = \proj j t$, and
  $\projp i {t\param j} = y$.
We now continue to reason by deduction:
  \begin{align*}
    w' &= t \param j \param i & \text{By def}\\
    {\CP i y {w'}} &= t\param j & \text{Because $\projp i {t\param j} = y $}  \\
    t'\param j &= t\param j & \text{By def}\\
    t' &= t &\text{Because $\proj j {t'} = \proj j t$} \\
    t' &= \CP i {\CP j x y} {\CP j z w} & \text{By def} \\
    t'\param i &= \CP j z w \\
    t'\param i\param j &= w
  \qedhere
  \end{align*}
\end{proof}

\begin{remark}
  At this point one may wonder if the system could have been set up to have
   $t\param i \param j = t\param j \param i$, and
    the equality between $A \op i \CP j x y \op j z$ and $A \op j
    \CP i x z \op i y$ rather than an isomorphism.
  % \item conversion rules such as $\CP j a b \param i = \CP j {a \param
  %     i}{b \param i}$.
 The answer is that the equation
  $$A \op i \CP j x y \op j z = A \op j \CP i x z \op i y$$  
  is inconsistent: in particular for $A = U$ one gets
  $$U \op i \CP j X P \op j Q = U \op j \CP i X Q \op i P$$
  for arbitrary $P$ and $Q$ of type $U \op i X$.  The above equality
  in turn implies
  $$(x:X) â†’ P x â†’ Q x â†’ U = (x:X) â†’ Q x â†’ P x â†’ U$$
  for arbitrary predicates $P$ and $Q$ over $X$, which is obviously
  inconsistent.
\end{remark}
\begin{theorem}
  If the type $A$ and the term $a$ do not depend on either $i$ or $j$,
  and $a' : A \op i a$ (not depending on $i$ or $j$ either), then
  %is related to the canonical proof ($a \param i$), \ie, formally
  $A \op i \CP j a {a \param i} \op j a'$.
\end{theorem}
\begin{proof}
We can construct the following closed term:
  \begin{align*}
    &q   : (A:U) â†’ (x:A) â†’ (x':A \op i x) â†’ A \op i \CP j x {x \param i} \op j x'\\
    &q   : (A:U) â†’ (x:A) â†’ (x':A \op i x) â†’ A \op i x \op j x' &\text{by \textsc{Surj-Param}}\\
    &q\, A\, x\, x' = x' \param j
  \end{align*}
The result is obtained by substituting $a$ for $x$ and $a'$ for $x'$.
\end{proof}

To conclude the section we note that by iterating parametricity $n$
times, one creates $n$-ary relations between proofs of relations of
arity $n-1$. Furthermore, the above results carry over to the $n$-ary
case. That is, for each $k < n$, one can construct a function
$\sigma_k$, which exchanges the arguments $k$ and $k+1$ of a
relation. Furthermore, these functions satisfy the laws of the
generators of the symmetric group.

\section{Presheaf model}
\label{sec:model}
In this section we show how to interpret our type theory by a presheaf model.
% \todo{General idea for those who won't read it}

\begin{definition}
  If $I$ and $J$ are two \emph{finite} subsets of $ğ•€$, we call
  \emph{color map} any function $f : I â†’ J âˆª \{0\}$ such that
  $i_1 = i_2$ for any $i_1, i_2 âˆˆ I$ with $f(i_1) = f(i_2) âˆˆ J$.
  We then note $f : I â†’ J$.
\end{definition}

\begin{definition}[Category $\pI{}$]
  \label{def:pI}
  Let objects be finite color sets and morphisms be color maps.
  If $f : I â†’ J$ and $g : J â†’ K$, we define the composition $fg : I â†’ K$
  as $fg(i) = 0$ if $f(i) = 0$ and $fg(i) = g(f(i))$ if $f(i) âˆˆ J$.
  We write $1_I : I â†’ I$ for the identity map, and define it as $1_I(i) = i$ for each $i âˆˆ I$.
  It is easy to check that \pI{} is a category (see \cite[ex.~9.7
  p.~176]{PittsAM:nomsns} for another description of this category).
\end{definition}

If $f : I â†’ J$, $i âˆ‰ I$ and $j âˆ‰ J$, we note
$(f, i = j) : I,i â†’ J,j$ the map defined by $(f,i=j)(i) = j$ and
$(f,i=j)(k) = k$ $âˆ€ k âˆˆ I$.

If $f : I,i â†’ J$ is such that $f(i) = 0$, we note $f-i : I â†’ J$ the map
defined by $(f-i)(k) = f(k)$ $âˆ€ k âˆˆ I$.

If $f : I,i â†’ J,j$ is such that $f(i) = j$, we note $f-i : I â†’ J$ the map
defined by $(f-i)(k) = f(k)$ $âˆ€ k âˆˆ I$.

For an object $I$ and $i âˆ‰ I$, we note $Î¹_i : I â†’ I,i$ the inclusion
map, defined by $Î¹_i(k) = k$ $âˆ€ k âˆˆ I$.

\begin{definition}[Projection]
   We say that a morphism $Î± : I â†’ I_Î±$ is a \emph{projection} if
   $I_Î± âŠ† I$,
   $Î±(i) = 0$ for each $i âˆˆ I \backslash I_Î±$, and
   $Î±(i) = i$ for each $i âˆˆ I_Î±$.
\end{definition}
\begin{definition}[Total maps]
  Injective morphisms, noted $h : I â†£ J$, are the \emph{total} ones, \ie,
  those verifying $h(i) â‰  0$ for all $i âˆˆ I$.
\end{definition}
\begin{remark}[Morphism decomposition]
  Any morphism $f : I â†’ J$ has a
  unique decomposition into a projection map
  $Î± : I â†’ I_Î±$ and a total map $h : I_Î± â†£ J$.
%  \ifthenelse{\boolean{tikz}}{
%  \begin{center}%
%  \begin{tikzpicture}[node distance=4\baselineskip]%
%      \node              (I)  {$I$};
%      \node[below of=I]  (Ia) {$I_Î±$};
%      \node[right of=Ia] (J)  {$J$};
%
%      \draw[->,dotted] (I) to node[left] {$Î±$} (Ia);
%      \draw[->] (I) to node[above right] {$f$} (J);
%      \draw[to reversed->,dotted] (Ia) to node[below] {$h$} (J);
%  \end{tikzpicture}%
%  \end{center}%
%  }{}
\end{remark}

\begin{definition}[$I$-set]
  We call $I$-element any tuple indexed by the subsets of $I$: $(u_J)_{J âŠ† I}$.
  An $I$-set is a set of $I$-elements.  For instance, the elements of a
  $\{i,j\}$-set are of the form $u = (u_âˆ…,u_i,u_j,u_{i,j})$.
  Alternatively, such an element can be seen as a tuple $(u_Î±)$ indexed
  by the projections $Î± : I â†’ I_Î±$.
\end{definition}
  %
  If $a,b$ are $I$-elements and $j âˆ‰ I$, we define the $(I,j)$-element
  $(a ,_j b)$ as $(a ,_j b)_J â‰” a_J$ if $j âˆ‰ J$ and $(a ,_j b)_{J,j} â‰” b_J$.
  %
  Any $(I,i)$-element (where $I,i$ is a shorthand for $I âˆª \{i\}$ with
  $i âˆ‰ I$) can be written $u = (u_J)_{J âŠ† I,i} = (u_J)_{J âŠ† I} âˆª (u_{J,i})_{J âŠ† I}$;
  We can therefore define the $I$-elements $u (i\,0) â‰” (u_J)_{J âŠ† I}$ and
  $u Â· i â‰” (u_{J,i})_{J âŠ† I}$.
  (Hence by definition $u = (u (i\,0) ,_i u Â· i)$.)

Recall that a \emph{presheaf} $F$ on $\pI^\opp$ is given by a family of
sets $F(I)$ together with restriction maps $F(I) â†’ F(J)$, $u â†¦ uf$ for
$f : I â†’ J$ satisfying $u1 = u$ and $(uf)g = u(fg)$.
Note that the category of presheaves on $\pI^\opp$ is equivalent to the
category $\mathbf{Res}$ of nominal restriction sets \cite[rem.~9.9 p.~161]{PittsAM:nomsns}.
%
We use a refined presheaf on $\pI^\opp$ by requiring two further conditions:
%
\begin{enumerate}
  \item for any object $I$, $F(I)$ is an $I$-set; and
  \item for any projection map $Î± : I â†’ I_Î±$, the restriction
    map $F(I) â†’ F(I_Î±)$, $u â†¦ uÎ±$ is the projection operation, \ie,
    $uÎ±_J = u_J$ for any $J âŠ† I$.
\end{enumerate}
%
Seeing an $I$-element $u$ as a tuple indexed by projection maps
$Î± : I â†’ I_Î±$, the second requirement can be written $(uÎ±)_Î² = u_{Î±Î²}$.

\smallskip
A context $Î“ âŠ¢$ is interpreted by a (usual) presheaf on $\pI^\opp$, \ie,
by a family of sets $Î“(I)$ for each object $I$, together with
restriction maps $Î“(I) â†’ Î“(J)$, $Ï â†¦ Ïf$ for $f : I â†’ J$ satisfying the
conditions $Ï1 = Ï$ and $(Ïf)g = Ï(fg)$.

A type $Î“ âŠ¢ A$ is interpreted by an $I$-set $AÏ$ for each object $I$ and
$Ï âˆˆ Î“(I)$,
together with restriction maps $AÏ â†’ A(Ïf)$, $u â†¦ uf$ if $f : I â†’ J$
satisfying $u1 = u$ and $(uf)g = u(fg)$ for any $g : J â†’ K$.
Furthermore the map $AÏ â†’ A(ÏÎ±)$, $u â†¦ uÎ±$ is the projection operation.

A term $Î“ âŠ¢ a : A$ is interpreted by a $I$-element $aÏ âˆˆ AÏ$ for each
object $I$ and $Ï âˆˆ Î“(I)$, such that $aÏf = a(Ïf)$ for any $f : I â†’ J$.

If $Î“âŠ¢$ and $Î“ âŠ¢ A$ we define the interpretation of $Î” = Î“,x:A$
by taking $âŸ¨Ï,x=uâŸ© âˆˆ Î”(I)$ to mean $Ï âˆˆ Î“(I)$ and $u âˆˆ AÏ$.
The restriction map is defined by $âŸ¨Ï,x=uâŸ©f = âŸ¨Ïf, x=ufâŸ©$.

If $Î“âŠ¢$ we define the interpretation of $Î” = Î“,i:ğ•€$ by taking
$[Ï,i=Ï†] âˆˆ Î”(I)$ to mean either $Ï† = 0$ and $Ï âˆˆ Î“(I)$, or
$Ï† = j âˆˆ I$ and $Ï âˆˆ Î“(I\backslash\{j\})$.
The restriction map is defined by
$[Ï,i=0]f = [Ïf,i=0]$ and $[Ï,i=j]f = [Ï(f-j),i=f(j)]$.
\begin{remark}
  In other words,
  $Î“,x:AâŠ¢$ is interpreted by the cartesian product $(ÏâˆˆÎ“) Ã— AÏ$ of the
  interpretations of $Î“âŠ¢$ and $Î“âŠ¢A$, while
  $Î“,i:ğ•€âŠ¢$ is interpreted by the separated product \cite[sec.~3.4
  p.~54]{PittsAM:nomsns} $Î“ âˆ— ğ•€$ of the
  interpretation of $Î“âŠ¢$ and $ğ•€ âˆª \{0\}$:
  $$Î“ âˆ— ğ•€(I) = \{ [Ï,i=0] \mid Ï âˆˆ Î“(I) \} âˆª
               \{ [Ï,i=j] \mid j âˆˆ I, Ï âˆˆ Î“(I\backslash\{j\}) \}$$
  %
  We also note that $Î“,i:ğ•€,j:ğ•€ âŠ¢$ and $Î“,j:ğ•€,i:ğ•€ âŠ¢$ are respectively
  interpeted as the sets of $[Ï,i=Ï†,j=Ï†']$ and $[Ï,j=Ï†,i=Ï†']$, which are
  trivially isomorphic.
%  \begin{align*}
%    Î“ âˆ— ğ•€ âˆ— ğ•€(I) =& \{ [Ï,i=0,j=0] \mid Ï âˆˆ Î“(I) \} âˆª
%      \{ [Ï,i=k,j=0] \mid k âˆˆ I, Ï âˆˆ Î“(I\backslash\{k\}) \} âˆª \\
%    & \{ [Ï,i=0,j=l] \mid l âˆˆ I, Ï âˆˆ Î“(I\backslash\{l\}) \} âˆª \\
%    & \{ [Ï,i=k,j=0] \mid k âˆˆ I, k âˆˆ I\backslash\{l\} I, Ï âˆˆ Î“(I\backslash\{k,l\}) \}
%  \end{align*}
\end{remark}

The above refinement on presheaves is necessary for the interpretation
of some of our syntactic constructions.  Indeed, without this refinement,
it is not clear how to validate the equality \textsc{Pair-Pred}:
${{(\CTimes i {x:A} P[x])} \op i a = P[a]}$.

\smallskip
The semantics we define satisfies the substitution law. That is, if $Î“,x:A âŠ¢ B$
and $Î“ âŠ¢ a:A$ then for any $Ï âˆˆ Î“(I)$ we have
$B[a]Ï = BâŸ¨Ï,x=aÏâŸ©$.
It also satisfies the substitution law on colors, \ie, if $Î“,i:ğ•€ âŠ¢ A$
then for any $Ï âˆˆ Î“(I)$ and $j âˆ‰ I$ we have
$A(i 0)Ï = A[Ï,i=0] = A[Ï,i=j](j\, 0)$.
(Since $[Ï,i=0] âˆˆ Î“âˆ—ğ•€(I)$ and $[Ï,i=j] âˆˆ Î“âˆ—ğ•€(I,j)$, $A(i\, 0)Ï$ and
$A[Ï,i=0]$ are $I$-sets while $A[Ï,i=j]$ is a $(I,j)$-set.)
For establishing these properties, we proceed as \citet{Aczel98onrelating}.

\smallskip
We proceed to interpret each type construction.
\begin{description}
  \item[\sc Pi.]
    Assume $Ï âˆˆ Î“(I)$. We define $((x:A) â†’ B)Ï$ as a $I$-set.
    An $I$-element of $((x:A) â†’ B)Ï$ is defined as a tuple $Î» = (Î»_Î±)$,
    where each $Î»_Î±$ is a family of elements indexed by a total map $f : I_Î± â†£ J$:
    $$Î»_{Î± f} âˆˆ \prod_{u âˆˆ A(ÏÎ±f)} BâŸ¨ÏÎ±f,x=uâŸ©$$
    such that
    $\app{Î»_{Î±f}}{u} g = \app{Î»_{Î± fg}}{ug}$ for $f : I_Î± â†£ J$ total and
    for \emph{any} $g : J â†’ K$.
    Because any map $I â†’ J$ has an unique decomposition as a projection and a total
    map, we can consider $Î»_f$ for an arbitrary map $f : I â†’ J$.

    If $f : I â†’ J$ is an arbitrary map, we define $Î» f$ to be the tuple
    $(Î»f_Î²)$ where $Î»f_Î²$ is the family $Î»f_{Î²g} = Î»_{fÎ²g}$.
    %
    With this definition, we directly have $Î»Î±_{Î²} = Î»_{Î±Î²}$.

    This is similar to the usual interpretation of dependent product in
    presheaf models \citep{Hofmann97syntaxand,bezem2014model}; but to
    satisfy our first extra condition on presheaves we present
    each element as a tuple, which can be done naturally by repartitioning
    the family as follows:
    $(Î»_f)_{f : I â†’ J} = (Î»_{Î±g})_{I_Î± âŠ† I, g : I_Î± â†£ J} â‰…
     ((Î»_{Î±g})_{g : I_Î± â†£ J})_{I_Î± âŠ† I}$


  \item[\sc Universe.]
    The universe $U$ is interpreted as a presheaf over \pI. An element $A$ of
    $U(I)$ is a tuple $(A_Î±)$ where each $A_Î±$ is a family of sets
    $A_{Î± f}$ for $f : I_Î± â†£ J$ \emph{total} together with restriction
    maps $A_{Î± f} â†’ A_{Î± fg}$, $u â†¦ ug$ for $f : I_Î± â†£ J$ total
    and $g : J â†’ K$ arbitrary, such that $u1 = u$ and $(ug)h = u(gh)$.

    As before, such data define a set $A_f$ for an arbitrary map $f : I â†’ J$
    with restriction maps $A_f â†’ A_{fg}$ if $g : J â†’ K$.

    If $f : I â†’ J$ is an arbitrary map, we define $Af$ by taking $Af_{Î²g}$
    to be the set $A_{fÎ²g}$, together with restriction maps $Af_{Î²g} â†’ Af_{Î²gh}$
    defined as the given maps $A_{fÎ²g} â†’ A_{fÎ²gh}$.
    %
    We can then check, as before, that we have $AÎ±_{Î²} = A_{Î±Î²}$

    As before, this is similar to the usual interpretation of universe in
    presheaf models, where each element is presented as a tuple.


  \item[\sc Out.]
    Assume $Ï âˆˆ Î“(I)$. We need to define the $I$-set $(A \op {i} a)Ï$.
    Let $j = \fresh I$.
    By the induction hypotheses we get a $(I,j)$-set $A[Ï,i=j]$,
    and the $I$-element $aÏ$ belongs to
    $A(i\,0)Ï = A[Ï,i=0] = A[Ï,i=j](j 0)$.

    We define $(A \op {i} a)Ï$ to be the set of $I$-elements $v$ such that
    $(aÏ,_j v) âˆˆ A[Ï,i=j]$.
    If $v$ is such an element and $f : I â†’ J$ and $k=\fresh J$, then
    $vf$ is defined by the equation $(aÏf,_k vf) = (aÏ ,_j v)(f, j=k)$.


  \item[\sc In-Pred.]
    Assume $[Ï,i=Ï†] âˆˆ Î“âˆ—ğ•€(I)$.  We define the $I$-set $(\CTimes i {x:A} P)[Ï,i=Ï†]$
    by case analysis on $Ï† âˆˆ Iâˆª\{0\}$.
    If $Ï† = 0$ then $Ï âˆˆ Î“(I)$, and we define $(\CTimes i {x:A} P)[Ï,i=0]$ as
    the $I$-set $AÏ$.
    If $Ï† = j âˆˆ I$ then $Ï âˆˆ Î“(I\backslash\{j\})$, and we define
    $(\CTimes i {x:A} P)[Ï,i=j]$ as the $I$-set of $(u ,_j v)$ where
    $u âˆˆ AÏ$ and $v âˆˆ PâŸ¨Ï,x=uâŸ©$.


  \item[\sc Decode.]
    Assume $Ï âˆˆ Î“(I)$.  We have $AÏ âˆˆ U(I)$ and we define
    $\El{A}Ï$ to be the set $AÏ_1$.
    The restriction map $\El{A}Ï â†’ \El{A}Ïf$, $u â†¦ uf$ is defined
    using the restriction map $AÏ_1 â†’ AÏ_f$ and the fact that we have
    $AÏ_f = A(Ïf)_1$.
\end{description}

\begin{remark}
  Our calculus does not have any base type, but they could be interpreted
  by modifying their usual interpretation as a constant presheaf into an
  isomorphic $I$-set.
  For instance, the base type of natural numbers would be interpreted as
  the $I$-set of $(n_J)_{J âŠ† I}$ where $n_âˆ… âˆˆ â„•$ and $n_J = 0$ for any
  non-empty $J âŠ† I$.
\end{remark}

\bigskip
We now describe how to interpret terms.
\begin{description}
  \item[\sc Var.]
    We define $xâŸ¨Ï,y=uâŸ©$ to be $u$ if $x = y$, and $xÏ$ otherwise.
    We define $x[Ï,i=Ï†]$ to be $xÏ$ if $Ï† = 0$, and
    $x(ÏÎ¹_j)$ if $Ï† = j$.

  \item[\sc Lam.]
    We define $\app{(Î» x:A.b)Ï_f}{u}$ to be $bâŸ¨Ïf,x=uâŸ©$

  \item[\sc App.]
    We define $(t\,u)Ï$ to be $\app{tÏ_1}{uÏ}$

  \item[\sc In-Abs.]
    Assume $[Ï,i=Ï†] âˆˆ Î“âˆ—ğ•€(I)$.  We define the $I$-element $(a ,_i p)[Ï,i=Ï†]$
    by case analysis on $Ï† âˆˆ I âˆª \{0\}$.
    If $Ï† = 0$ then $Ï âˆˆ Î“(I)$, and we take $(a ,_i p)[Ï,i=0]$ to be
    $aÏ âˆˆ A(i\,0)Ï = A[Ï,i=0]$.
    If $Ï† = j âˆˆ I$ then $Ï âˆˆ Î“(I\backslash\{j\})$, and we take
    $(a ,_i p)[Ï,i=j]$ to be $(aÏ ,_j pÏ)$.

  \item[\sc In-Fun.]
    Assume $[Ï,i=Ï†] âˆˆ Î“âˆ—ğ•€(I)$.  We define the $J$-element ${\fp i t u}[Ï,i=Ï†]_f$
    by case analysis.
    If $Ï† = 0$, then $Ï âˆˆ Î“(I)$ and $Ïf âˆˆ Î“(J)$; we define
    $w = {\fp i t u}[Ï,i=0]_f$ by $\app{w}{a} = \app{tÏ_f}{a}$.
    If $Ï† = j âˆˆ I$ and $f(j) = 0$, then $Ï âˆˆ Î“(I\backslash\{j\})$ and $Ï(f-j) âˆˆ Î“(J)$;
    we define $w = {\fp i t u}[Ï,i=j]_f$ by $\app{w}{a} = \app{tÏ_{f-j}}{a}$.
    If $Ï† = j âˆˆ I$ and $f(j) = k âˆˆ J$, then $Ï âˆˆ Î“(I\backslash\{j\})$ and $Ï(f-j) âˆˆ Î“(J\backslash\{k\})$;
    we define $w = {\fp i t u}[Ï,i=j]_f$ by
    $\app{w}{(a ,_k b)} = ( \app{tÏ_{f-j}}{a} ,_k {\app{\app{uÏ_{f-j}}{a}}{b}} )$.

  \item[\sc Color-Elim.]
    Assume $Ï âˆˆ Î“(I)$.  We define $(a \param i)Ï$ as
    $a[Ï,i=j]Â·j$ where $j = \fresh{J}$.
\end{description}

\begin{theorem}[Convertible terms are semantically equal]~
  \label{thm:convertible-in-model}
  \begin{itemize}
    \item If $Î“ âŠ¢ Aâ‚$ and $Î“ âŠ¢ Aâ‚‚$ with $Aâ‚ = Aâ‚‚$, then
      $Aâ‚Ï = Aâ‚‚Ï$ for any $Ï : Î“(I)$.
    \item If $Î“ âŠ¢ aâ‚ : A$ and $Î“ âŠ¢ aâ‚‚ : A$ with $aâ‚ = aâ‚‚$, then
      $aâ‚Ï = aâ‚‚Ï$ for any $Ï : Î“(I)$.
  \end{itemize}
\end{theorem}
\begin{proof}
  By simultaneous induction on the derivation.
  We only show the conversion rules \textsc{Pair-Param},
  \textsc{Pair-Pred} and \textsc{Surj-Param} here; other rules involving
  colors can be proven in a similar fashion, while $Î²$ and $Î·$ can be
  proven in the usual way.

  \begin{description}
    \item[\sc Pair-Param.]
      Let $Ï âˆˆ Î“(I)$ and $j = \fresh I$.  We have
      \begin{align*}
        &v âˆˆ ({((x:A)\times_i P)} \op {i} a)Ï
        \\
        \text{ iff. }& (aÏ ,_j v) âˆˆ (\CTimes i {x:A} P)[Ï,i=j]
        \\
        \text{ iff. }& (aÏ ,_j v) âˆˆ \left\{ (u ,_j w) \mid u âˆˆ AÏ, w âˆˆ PâŸ¨Ï,x=uâŸ© \right\}
        \\
        \text{ iff. }& v âˆˆ PâŸ¨Ï,x=aÏâŸ©
        \\
        \text{ iff. }& v âˆˆ P[a]Ï
      \end{align*}

    \item[\sc Pair-Pred.]
      Let $Ï âˆˆ Î“(I)$ and $j = \fresh I$.  We have
      $ ((a ,_i p) \param i)Ï
      = (a ,_i p)[Ï,i=j]Â·j
      = (aÏ ,_j pÏ) Â· j
      = pÏ$

    \item[\sc Surj-Param.]
      For each $Ï âˆˆ Î“(I)$ we have
      $(t(i\,0) ,_i tÂ·i)[Ï,i=0] = t(i\,0)Ï = t[Ï,i=0]$, and
      if $j âˆ‰ I$ then
      $ (t(i\,0) ,_i tÂ·i)[Ï,i=j]
      = (t(i\,0)Ï ,_j (tÂ·i)Ï)
      = (t[Ï,i=j](j\,0) ,_j t[Ï,i=j]Â·j)
      = t[Ï,i=j]$.
      Hence $(t(i\,0) ,_i tÂ·i)Ï = tÏ$ for any $Ï âˆˆ Î“âˆ—ğ•€(I)$.
      \qedhere
  \end{description}
\end{proof}

\begin{remark}
  As noted earlier, the types
  $U \op i (X ,_j P) \op j Q$ and $U \op j (X ,_i Q) \op i P$
  are not convertible.
  Their semantic interpretations are not equal either.  Indeed
  taking $Ï âˆˆ Î“(I)$, $k = \fresh{I}$ and $l = \fresh{I,k}$,
  we have
  (leaving out the context interpretation $Ï$ for the sake of
  readability)
  on the one hand
  \begin{align*}
    &v âˆˆ (U \op i (X ,_j P) \op j Q) Ï
    \\
    \text{ iff. }& (QÏ ,_k v) âˆˆ (U \op i (X ,_j P))[Ï,j=k]
    \\
    \text{ iff. }& ((X ,_j P)[Ï,j=k] ,_l (QÏ ,_k v)) âˆˆ U(l,k)
    \\
    \text{ iff. }& ((XÏ ,_k PÏ) ,_l (QÏ ,_k v)) âˆˆ U(l,k)
  \end{align*}

  while on the other hand
  \begin{align*}
    &v âˆˆ (U \op j (X ,_i Q) \op i P) Ï
    \\
    \text{ iff. }& (PÏ ,_k v) âˆˆ (U \op j (X ,_i Q))[Ï,i=k]
    \\
    \text{ iff. }& ((X ,_i Q)[Ï,i=k] ,_l (PÏ ,_k v)) âˆˆ U(k,l)
    \\
    \text{ iff. }& ((XÏ ,_k QÏ) ,_l (PÏ ,_k v)) âˆˆ U(k,l)
  \end{align*}

  Hence $(U \op i (X ,_j P) \op j Q) Ï â‰  (U \op j (X ,_i Q) \op i P) Ï$
  since the map $U(l,k) â†’ U(k,l)$, $u â†¦ ug$ where $g(k) = l$ and $g(l)=k$
  is not the identity.
\end{remark}


\begin{theorem}[Validity]
  If $Î“ âŠ¢ a : A$ then $aÏ âˆˆ AÏ$ for any $Ï âˆˆ Î“(I)$.
\end{theorem}
\begin{proof}
  By induction on the typing judgment.  We only show the cases \textsc{In-Abs} and \textsc{Color-Elim}.  \textsc{In-Fun} is similar to the former, and the other
  cases match the usual proof (using \fref{thm:convertible-in-model} for \textsc{Conv}).
  \begin{description}
    \item[\sc In-Abs.]
      Assume $[Ï,i=Ï†] âˆˆ Î“âˆ—ğ•€(I)$.  We proceed by case analysis on $Ï† âˆˆ I âˆª \{0\}$.
      If $Ï† = 0$ then $Ï âˆˆ Î“(I)$, and we have
      $(a ,_i p)[Ï,i=0] = aÏ âˆˆ A(i\,0)Ï = A[Ï,i=0]$.
      If $Ï† = j âˆˆ I$ then $Ï âˆˆ Î“(I\backslash\{j\})$, and we have
      $(a ,_i p)[Ï,i=j] = (aÏ ,_j pÏ)$;
      Since by induction hypothesis $pÏ âˆˆ (A \op {i} a)Ï$, we conclude
      by definition that $(aÏ ,_j pÏ) âˆˆ A[Ï,i=j]$.

    \item[\sc Color-Elim.]
      Assume $Ï âˆˆ Î“(I)$.
      We need to show that $(aÂ·i)Ï âˆˆ (A \op i {a(i\,0)})Ï$, \ie, that
      $ (a(i\,0)Ï ,_j (aÂ·i)Ï) âˆˆ A[Ï,i=j]$ where $j = \fresh I$.
      By induction hypothesis $a[Ï,i=j] âˆˆ A[Ï,i=j]$, hence
      we have
      $(a(i\,0)Ï ,_j (aÂ·i)Ï) = (a[Ï,i=j](j\,0) ,_j a[Ï,i=j]Â·j) = a âˆˆ A[Ï,i=j]$.
    \qedhere
  \end{description}

\end{proof}

\section{Related Work}

\subsection{Our own line of work}
This work continues a line of work aiming at a smooth integration of
parametricity with dependent types
\citep{bernardy_parametricity_2010,bernardy_realizability_2011,bernardy_proofs_2012,bernardy_computational_2012,bernardy_type-theory_2013}. The present work offers two improvements over previous publications:
1. a denotational semantics, and
2. a much simplified syntax, suitable as the basis of a proof assistant.

The simplification of syntax is allowed by foregoing the preservation
of functions by parametricity. We call preservation of functions by
parametricity the property that if $f$ were a function, then the
canonical proof that $f$ is parametric (denoted $f \param i$ here) is
also a function. To our knowledge, following \citet{reynolds_types_1983}, all parametric \emph{models} of parametricity (both syntactical and semantical ones) have this property.
However, having this property in the \emph{syntax} implies that
certain function arguments must be swapped when performing the
substitution of beta reduction, as identified by
\citet{bernardy_computational_2012}.  In the present system, the
parametric interpretation of functions is instead merely isomorphic to
a function, thanks to the {\sc In-Fun} rule (\fref{thm:iso-fun}). This
isomorphism (rather than equality) means on the one hand that the
swapping of arguments is handled by the usual rules of logic, instead
of special-purpose ones. On the other hand, obtaining the classical
parametric interpretation of types requires some purely mechanical
work by the user of the logic.

\subsection{Parametric Models of Type Theory vs. Parametric Type Theories}

Two pieces of work propose alternative parametric models of
type theory
\citep{atkey_relationally_2014,krishnaswami_internalizing_2013}, but
do not integrate parametricity in the syntax of the calculus. This
means that, while certain consequences of parametricity can be made
available in the logic, via constants validated by the model,
parametricity itself is not available. In this paper, we not only
propose a parametric model, but also show how it can be used to
interpret parametricity straight up in the syntax of the type theory.


\subsection{Various kinds of models}
Another characterizing feature of proposals for parametricity is the
kind of model underlying the
semantics. \Citet{krishnaswami_internalizing_2013} propose a model
based on Q-PER. \Citet{atkey_relationally_2014} propose a model based
on reflexive graphs. The model that we use is based on cubes
(functions from subsets of colors). In
our 2012 work the cubes were reified as syntax in
an underlying calculus, while in the present work they refine a presheaf structure.

\subsection{Presheaf models}

The presheaf construction used in this paper follows a known template,
used for example by \citet{bezem2014model,DBLP:journals/corr/Pitts14}
to model univalence in type theory. Not only both models use a
presheaf, but they also have the same underlying category $\pI$.
This means as all these models have an additional cubical structure.
We find remarkable that cubical structures are useful for modeling both
parametricity and univalence.
\citet{altenkirch2014syntax} give a syntax for
\citeauthor{bezem2014model}'s Cubical Type Theory, effectively modelling
univalence by internalization of their model.
The present work further refines the model by interpreting terms as
$I$-elements, which is essential to interpret our special-purpose
pairing constructions.

\section{Future work and conclusion}
We have defined a new type theory with internalized parametricity.
Thanks to our model construction, we have proved the consistency of
the system. The missing piece to construct a type-checker is a
decision algorithm for the conversion relation.  This checker could
then be used as a minimal proof assistant for a type theory with
parametricity.

\bigskip
\noindent
\textbf{Acknowledgment:}
The fact that the category of partial bijections \pI{} should be
relevant for internalization of parametricity became apparent through
discussions between Thorsten Altenkirch and the second  author about
the paper \citep{bernardy_computational_2012}.

We are extremely grateful to Simon Huber for finding a flaw in an
earlier version of this paper, and helping us to fix it.
We also thank Peter Dybjer and Patrik Jansson for valuable feedback and
discussion.

\newcommand{\newblock}{}
\bibliographystyle{abbrvnat}
\bibliography{PaperTools/bibtex/jp,tt}
\end{document}
