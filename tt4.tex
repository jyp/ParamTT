\documentclass[english]{PaperTools/latex/lipics}
\graphicspath{{PaperTools/latex/}}
\usepackage{natbib}
\usepackage[utf8]{inputenc}
\usepackage{stmaryrd}
\usepackage{amssymb,amstext,amsmath}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage{fancyref}
\usepackage{todonotes}
\input{fancyrefs}
\usepackage{tikz}
\usetikzlibrary{arrows}

\newcommand\CC[4]{(#2,_{#1} #3)}
\newcommand\CP[3]{(#2,_{#1} #3)}
\newcommand\CTimes[2]{(#2) ×_{#1}}
\newcommand\SW[2]{\mathsf{SW}^{#1}_{#2}}
\newcommand\sw[2]{\mathsf{sw}^{#1}_{#2}}
\newcommand\dom{\mathsf{dom}}
\newcommand\param[1]{\!\cdot\!#1}
\newcommand\pvar[2]{{#1}^{(#2)}}
\newcommand\op[1]{∋_{#1}}
\newcommand\ip[3]{Σ^{#1} {#2}\,{#3}}
\newcommand\fp[3]{⟨#2 ,_{#1} #3⟩}
\newcommand\mor[2]{({#1}\,{#2})}
\newcommand\proj[2]{{#2}\,\mor{#1}0}
\newcommand\projp[2]{\proj{#1}{(#2)}}

\newcommand\comment[1]{}
\input{unicodedefs}

\def\pI{\ensuremath{\mathbf{pI}}}
\def\fresh#1{\mathsf{fresh}(#1)}
\def\Hom#1#2{\mathbf{Hom}(#1,#2)}
\def\ie{\textit{i.e.}}
\def\app#1#2{\mathsf{app}(#1,#2)}
\def\El#1{\mathrm{El}(#1)}
\def\opp{\mathrm{op}}

\title{A presheaf model of parametric type-theory}

\author{}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
  We propose a new type-theory with internalized
  parametricity. Compared to previous similar proposals, this version
  comes with a denotational semantics which is a refinement of the
  standard presheaf semantics of dependent type theory. Further, this
  presheaf semantics is a refinement of the one used to interpret
  nominal sets with restriction.  The present calculus is a candidate for the
  core of a proof assistant with internalized parametricity.
\end{abstract}

\section{Introduction}
In lambda-calculi, every type can be interpreted as a predicate, which
its inhabitants are guaranteed to satisfy.
%
A simple example is that if a function $f$ has type $(A : U) → U → U$ ---
the type of the polymorphic identity --- then the following
proposition holds:
%
\[
  (A : U) → (P : A → U) → (x : A) → P x → P (f A x)
\]
%
(which implies that $f$ must return exactly its argument).
The above result, \emph{abstraction}, has proved useful for reasoning
about functional programs \citep{wadler_theorems_1989}. It also has deep
theoretical implications: for example, the induction principle over Church numerals
can be deduced from it \citep{wadler_girardreynolds_2007}.


The abstraction theorem is an invention of
\citet{reynolds_types_1983}, which he used to give formal meaning to
polymorphism in the λ-calculus. He does so by a model construction
where types are interpreted as predicates and functions are interpreted
by predicate-preserving functions.

In this paper, we propose an extension of Reynolds' model, where a
type is interpreted as a hypercube of sets, predicates, relations and
so on. Our model supports the interpretation dependent type-theories,
and of parametricity itself (parametricity is parametric).  We take
advantage of this closure property by intergrating parametricity into
the syntax of the type-theory being interpreted.  This means that the
user of the logic can prove any parametricity result directly in the
logic, rather than having to resort to an external semantic
justification.

Our technical contributions are as follows:
\begin{itemize}
\item We propose a novel type-theory (\fref{sec:syntax}), and show
  that it internalises parametricity (\fref{sec:parametricity}).
  % In particular, we show that the calculus internalizes parametricity. 
  % in \fref{sec:abstraction}. \comment{Much of this is now in the appendix...}
\item We provide a presheaf model for this type-theory (\fref{sec:model}).
      This model is refinement of the presheaf semantics used to
      interpret nominal sets with
      restrictions~\citep{bezem2014model,DBLP:journals/corr/Pitts14}.
\end{itemize}

\section{Syntax}
\label{sec:syntax}
In the following section we define the syntax and typing-rules of our
parametric type-theory, as well as the equality judgement.

We assume a special symbol ‘0’, and a countable infinite set of other
symbols, called \emph{colors}.
The metasyntactic variables $i,j,\ldots$ range over colors, while
$I,J,…$ range over \emph{finite} sets of colors.
We suppose a fixed function $\fresh{·}$ such that
% JP: I remove \emph{gensym} which occurs nowhere else in the text
$\fresh{I} ∉ I$ for any finite color set $I$.
%
The main innovation of the type-theory
presented here is that terms may depend on (a finite number of)
colors.
\begin{definition}[Syntax of terms and contexts]
  \begin{align*}
    t,u,A,B & \coloneqq x & \text {variable} \\
            & \mid U & \text{universe} \\ 
            & \mid |A| & \text{code} \\ 
            & \mid \El{A} & \text{decode} \\
            & \mid λx:A. t & \text{abstraction} \\
            & \mid t u & \text{application} \\ 
            & \mid (x:A) → B & \text{product} \\
            & \mid \CP i t u & \text{colored pair} \\
            & \mid \CTimes i {x:A} B  & \text{colored type pair} \\
            & \mid \fp i t u & \text{colored function pair}\\
            & \mid A \op i u & \text{parametricity type} \\
            & \mid t \param i & \text{parametricity proof} \\
    \Gamma,\Delta & \coloneqq () \mid \Gamma,x:A
  \end{align*}
\end{definition}

We give a few intuitions to interpret the novel syntax, before giving formally the typing rules of the system. 
\begin{enumerate}
\item The type $A \op i u$ expresses that $u$ satisfies the
  parametricity predicate associated with the type $A$ on color $i$.
\item The term $a \param i$ yields a proof of $A \op i \proj i a$.
\item In the above, the term $\proj i a$ denotes a realiser of $a$,
  obtained by erasing the color $i$ (Erasure is detailed in
  \fref{def:color-subst}).
\item The forms $\CP i t u$, $\CTimes i {x:A} B$ and $\fp i t u$ allow to
  locally associate parametricity proofs with a given realizer.
\end{enumerate}



\begin{definition}[Typing judgements — à la Tarski]
We mutually define three judgments:
\begin{itemize}
\item $Γ⊢_I$ (Is the context $Γ$ is well-formed, assuming the color set $I$?).
\item $Γ⊢_I A$  (Is the type $A$ well-formed in $Γ$ and assuming the color set $I$?)
\item $Γ⊢_I a : A$  (Does the term $a$ have type $A$ in the context $Γ$ and assuming the color set $I$?)
\end{itemize}

\fbox{$Γ⊢_I$}
  \begin{mathpar}
    \inferrule[Empty]{~}{() ⊢_I }

    \inferrule[NewVar]{Γ⊢_I \\ Γ ⊢_I A }{ Γ,x:A ⊢_I }

  \end{mathpar}
 
\fbox{$Γ⊢_I A$}
 \begin{mathpar}

    \inferrule[Universe]{~}{Γ ⊢_I U}

    \inferrule[Decode]{Γ ⊢_I A : U}{Γ ⊢_I \El{A}}
    \\
    \inferrule[Pi]{Γ ⊢_I A \\ Γ,x:A ⊢_I B}{Γ ⊢_I (x:A) → B}

    \inferrule[Out]{Γ ⊢_{I,i} T \\ Γ ⊢_I a : \proj i T}{Γ ⊢_I T \op i  a}

    \inferrule[In-Pred]{Γ ⊢_{I} A \\ Γ,x:A ⊢_{I} B}{Γ ⊢_{I,i} \CTimes i {x:A} B}
 \end{mathpar}

\fbox{$Γ⊢_I a : A$}
  \begin{mathpar}
    \inferrule[Conv]{Γ ⊢_I t:A \\ A = B}{Γ ⊢_I t : B}

    \inferrule[Var]{Γ ⊢_I \\ x : A ∈ Γ}{Γ ⊢_I x : A}

    \inferrule[Code]{Γ ⊢_I A }{Γ ⊢_I |A| : U}

    \\\inferrule[Lam]{Γ,x:A ⊢_I b : B}{Γ ⊢_I λx:A.b : (x:A) → B}
 
    \inferrule[App]{Γ ⊢_I t : (x:A) → B[x] \\ Γ ⊢_I u : A}{Γ ⊢_I t u: B[u]}

    \\\inferrule[In-Abs]{Γ ⊢_I a : \proj i T \\Γ ⊢_I p : T \op i a}{Γ ⊢_{I,i} \CP i a p : T}

    \inferrule[In-Fun]
        {Γ ⊢_I t : \projp i {(x:A) → P[x]}\\\\
         Γ ⊢_I u : (x:\proj i A) → (x':A \op i x) → P[\CP i x {x'}] \op i f x}
        {Γ ⊢_{I,i} \fp i t u : (x:A) → P[x]}

    \inferrule[Color-elim]{Γ ⊢_{I,i} a : T}{Γ ⊢_I a \param i : T \op i {\proj i a}}
  \end{mathpar}
\end{definition}

The parametricity constructions ($·$ and $∋$) act like color
binders (they bring colors into scope), while the pairing constructs
remove colors from scope.
The equality relation used in the {\sc Conv} rule is detailed below in \fref{def:conversion}.

Additionally, for the above system to be well-founded, we need to
distinguish small and big types, and allow only small types to be
encoded in $U$. Small types are closed under product, $×_i$ and
$∋_i$. The distinction between big and small types being standard, and
to keep the presentation concise, we leave it implicit in the syntax.

% 'Morphism' means something only in the context of a category; hence Morphism application ==> Color substitution
\begin{definition}
  A \emph{color map} $f : I → J$ is a function $I → J ∪ \{0\}$ such that
  $f(i_1) = f(i_2)$ iff $i_1 = i_2$ whenever $f(i_1) = f(i_2) ∈ J$.
%
%
\end{definition}

\begin{definition}[Category $\pI{}$]
  \label{def:pI}
  Let objets be objects be finite color sets
  and morphisms be color maps.
  If $f : I → J$ and $g : J → k$, we define the composition $fg : I → K$
  as $fg(i) = 0$ if $f(i) = 0$ and $fg(i) = g(f(i))$ if $f(i) ∈ J$.
  We write $1_I : I → I$ for identity map, and define it as $1_I(i) = i$ for each $i ∈ I$.
  It is easy to check that we have a category (\cite[ex.~9.7 p.~176]{PittsAM:nomsns}).
\end{definition}

We note
\begin{itemize}
\item $(i\,0) : I,i → I$ the partial identity: $(i\,0)(i) = 0$ and $(i\,0)(j) = j$ for each $j ∈ I$; 
\item $ι_i : I → I,i$ the inclusion: $ι_i(i) =i$ for all $i ∈ I$. \todo{$i$ is used both free and bound? $ι_i(j) =i$ for all $j ∈ I$? }
\end{itemize}
Furthermore for each color map $f : I → J$, $i ∉ I$ and $j ∉ J$, we
note $f^{ij} : I,i → J,j$ the color map such that
$f^{ij}(i) = j$ and $f^{ij}(k) = f(k)$ for all $k ∈ I$.

\begin{definition}[Color substitution]~
  \label{def:color-subst}
  We consider a color map $f : I → J$ as a (color) substitution on terms,
  and define $af$ by structural induction on $a$.
\begin{align*}
  x f & = x \\
  U f & = U \\
  (λ(x:A).t) f &= λ(x:Af).tf \\
  (t\,u) f &= (tf) \, (uf) \\
  ((x:A)→B) f &= (x:Af)→(Bf) \\
  \CP {i} a p f &= \CP {j} {ag} {pg}
    & \text{if $f(i) = j ∈ J$, where g = $ι_i f (j\,0)$} \\
    &= a(ι_if)
    & \text{if $f(i) = 0$} \\
  (A ×_i B) f &= \CTimes {j} {Ag} {(Bg)}
    & \text{if $f(i) = j ∈ J$, where g = $ι_i f (j\,0)$} \\
    &= A(ι_if)
    & \text{if $f(i) = 0$} \\
  \fp {i} t u f &= \fp {j} {tg} {ug}
    & \text{if $f(i) = j ∈ J$, where g = $ι_i f (j\,0)$} \\
    &= u(ι_if)
    & \text{if $f(i) = 0$} \\
  (A \op {i} a) f &= (Af^{ij}) \op {j} (af)
    & \text{where $j = \fresh J$} \\
  (a · i) f &= (af^{ij}) · j
    & \text{where $j = \fresh J$} \\
  \\[.33\baselineskip]
  () f      &= () \\
  (Γ,x:A) f &= Γ f, x : A f
\end{align*}
\end{definition}

\begin{theorem}~
  \begin{itemize}
  \item $a1_I = a$
  \item $(af)g = a(fg)$ for any $f: I → J$ and $g : J → K$
  \end{itemize}
\end{theorem}
\begin{proof}
  By structural induction on $a$.
\end{proof}

\begin{theorem}[Color substitution preserves typing]
  If $Γ ⊢_I a : A$ then the term
$af$ is defined and $Γ f ⊢_J af : Af$
\end{theorem}
\begin{proof}
  By induction on the typing judgement.
\end{proof}

\comment{
\begin{definition}[Normal forms and neutral terms]~
  \begin{align*}
    \mathsf{Nf} ∋ u,v,A,B & \coloneqq
      U \mid λx:A. t \mid (x:A) → B \\
      & \mid \CP i u v \mid \fp i u v \\
      & \mid {(\CTimes {i₀} A B)} \op {i₁} {u_1 \cdots} \op {i_n} {u_n} &\quad \text{($i₀ \prec i₁ \prec \ldots \prec i_n$)} \\
      & \mid s \param {i₀} \cdots \param {i_{n-1}}                  &\quad \text{($i₀ \prec   < \ldots \prec i_{n-1}$)}
    \\
    \mathsf{Ne} ∋ s & \coloneqq x \mid s \, u
  \end{align*}
\end{definition}
}

\begin{definition}[Conversion]~
\label{def:conversion}
The convertibity of types used in the {\sc Conv} rule is defined
inductively by the following rules.
\begin{mathpar}
  \inferrule[Pair-App]{}{{\fp i t u} \, a      = (t\,{\proj i a} ,_i u\,{\proj i a}\,{(a \param i)})}
\and
  \inferrule[Pair-Param]{}{{(a,_i p)}\param i   = p}
\and
  \inferrule[Pair-Pred]{}{{(\CTimes i {x:A} B[x])} \op i a = B[a]}
\and
    \inferrule{}{\El{|A|} = A}
\and
    \inferrule{}{|\El{A}| = A}
\and
    \inferrule[β]{}{(λx:A. u[x]) t = u[t]}
\and
    \inferrule[η]{t x = u} {t = λ x:A.u}
    \and
    \inferrule[Surj-Param]{\proj i t = a \\ t \param i = p} {t = \CP i a p }
    \and
    \inferrule[Surj-Fun]{\proj i t = u \\ (t \CP i x y) \param i = v x y} {t = \fp i u v }
    \and
    \inferrule[Surj-Typ]{\proj i T = A \\ T \op i x = B} {T = \CTimes i {x:A} B }
    \and
    \inferrule[Refl]{~}{a = a}
    \and
    \inferrule[Sym]{a = b}{b = a}
    \and
    \inferrule[Trans]{a = b \\ b = c}{a = c}
  \end{mathpar}
Additionally, all congruences yield conversion rules.
\end{definition}


\begin{corollary}[Any term can be seen as a pair of a realizer and a parametricity proof]~
  \label{cor:equalities}
  \begin{itemize}
  \item $a = \CP i {\proj i a} {a \param i}$
  \item $T = \CTimes i {x:\proj i T} {(T \op i x)}$
  \item $f = \fp i {\proj i t} {λx x'. (t \CP i x {x'}) \param i}$
  \end{itemize}
\end{corollary}

\section{Parametricity}
\label{sec:parametricity}
In this section we prove that our system properly internalises
parametricity. We also illustrate the system by giving a few simple
proofs relying on parametricity (including iterated parametricity).

Contrary to previous type theories with internalized parametricity
\citep{bernardy_computational_2012, bernardy_type-theory_2013}, the
system presented here lacks equalities which allow to compute
parametricity types. Expressed in our syntax, those equalites would become the conversion rules:
$$U \op i A = A → U$$
and
$$((x:A) → B[x]) \op i f = (x:A) → (x' : A \op i x) → B[\CP i x {x'}] \op i (f x).$$

The absence of the above equalities allows for a simpler system, but
how can we ensure that all parametricity theorems hold?  The answer is
that the above relationships hold as isomorphisms.

We say that $A$ is isomorphic to $B$ iff.
\begin{enumerate}
  \item There exist $f : A → B$
  \item There exist $g : B → A$
  \item For any $x$, $f\, (g\, x) = x$
  \item For any $x$, $g\, (f\, x) = x$
\end{enumerate}
This notion of isomorphism is quite strong, because the equality
used in its definition is the conversion relation (defined in
\fref{def:conversion}).

\begin{theorem}
\label{thm:iso-univ}
$U \op i A$ is isomorphic to $A → U$.
\end{theorem}
\begin{proof}~
  \begin{enumerate}
  \item
    $\begin{array}[t]{l@{\,}l}
      f &: (Q : U \op i A) → A → U \\ 
      f & Q\, x = \CP i A Q \op i x
    \end{array}$
  \item
    $\begin{array}[t]{r@{\,}l}
      g &: (P : A → U) → U \op i A\\
      g &P = (\CTimes i {x:A} (P x)) \param i
    \end{array}$
  \item $\CP i A {(\CTimes i {y:A} (P y)) \param i} \op i x = (\CTimes i
    {y:A} (P x) \op i x = P x$ By $η$-contraction we get the desired result.
  \item $(\CTimes i {x:A} {\CP i A Q \op i x}).i = Q$ if $\CTimes i {x:A} {\CP i A Q \op i x} = \CP i A Q$. We then use equality for $×_i$. The first components are obviously equal. For the second components we are left with $\CP i A Q \op i x = \CP i A Q \op i x$, which holds by reflexivity.
  \qedhere
  \end{enumerate}
\end{proof}

\begin{theorem}
\label{thm:iso-fun}
$((x:A) → B[x]) \op i f$ is isomorphic to $(x:A) → (x' : A \op i x) → B[\CP i x {x'}] \op i {(f\, x)}$.
\end{theorem}
\begin{proof}~
  \begin{enumerate}
  \item $\begin{array}[t]{r@{\,}l}
      f &: (q : ((x:A) → B[x]) \op i f) → (x:A) → (x' : A \op i x) → B[\CP i x {x'}] \op i {(f x)}\\
      f &q\, x\, x' = (\CP i f q \CP i x {x'}) \param i
    \end{array}$
  \item $\begin{array}[t]{r@{\,}l}
      g &: ((x:A) → (x' : A \op i x) → B[\CP i x {x'}] \op i (f\,x)) →  ((x:A) → B[x]) \op i f\\
      g & p= \fp i f p \param i
    \end{array}$
  \item $(\CP i f {\fp i f p \param i} \CP i x x') \param i = ({\fp i
      f p} \CP i x {x'}) \param i = \CP i {f\, x} {p\, x\, x'} \param i = p\, x\, x'$
  \item $\fp i f {λx x'. (\CP i f q \CP i x {x'}) \param i} \param i$
    iff $\fp i f {λx x'. (\CP i f q \CP i x {x'}) \param i} = \CP i f
    q$, which is true by the equality rule for function pairing.
  \qedhere
  \end{enumerate}
\end{proof}

In practice, when carrying out parametricity proofs, many of the steps
of the above isomorphisms cancel each other and one obtains a simpler
proof. This property is illustrated by the following example:
parametricity for Church-encoded natural numbers.
(For the sake of simplicity, in the remainder of this section, we leave out the
distinction between types and their codes.)
\begin{example}
Let $N = ∀X. X → (X → X) → X$.
Proving (unary) parametricity for $N$ means that, assuming
\begin{itemize}
\item $f : N$
\item $A : U$
\item $P : A → U$
\item $z : A$
\item $z' : P z$
\item $s : A → A$
\item $s' : (x:A) → P x → P (s x)$
\end{itemize}
we can prove $P (f A z s)$.

Indeed, a proof term is the following:
%
\[
(f (\CTimes i {x:A} (P x)) \CP i z {z'} \fp i s {s'}) \param i
\]
\end{example}

\subsection{Iterating Parametricity}
In our system, one can use parametricity generically as follows:
\begin{align*}
p &: (A:U) → (x:A) → A \op i x\\
p\, x &= x\param i
\end{align*}
We have already seen that $A \op i $ corresponds to the parametricity
predicate for type $A$. We can iterate this operator to construct
relations. That is, given
\begin{align*}
  x & :A \\
  y & : A \op i x\\
  z & : A \op i x
\end{align*}
Then the type $A \op i \CP j x y \op j z$ is well formed ($∋$ is left
associative), and can be understood as a relation
between the parametricity proofs $y$ and $z$. The following results about this relation illustrate the expressivity of our system.
\begin{theorem}
If the type $A$ does not depend on either $i$ or $j$, the relation $λy z. A \op i \CP j x y \op j z$ is symmetric.
\end{theorem}
\begin{proof}
  We first construct the proof term:
  \begin{align*}
    &\sigma_1 : (x:A) → (y : A \op i x) → (z : A \op i x) → (w : A \op i \CP j x y \op j z) → A \op j \CP i x z \op i y \\
    &\sigma_1\, x\, y\, z\, w = \CP i {\CP j x y}{\CP j z w} \param j \param i
  \end{align*}
  And, by α-equivalence, $A \op j \CP i x z \op i y = A \op i \CP j x z \op j y$.
\end{proof}

\begin{theorem}
  Function $\sigma_1$ (defined above) is involutive in its last argument:
  \[ \sigma_1\, y\, x\, z\, (\sigma_1\, x\, y\, z\, w) = w \]
\end{theorem}
\begin{proof}
  Let
  \begin{align*}
    t &= \CP i {\CP j x y}{\CP j z w} \\
    w' &= t \param j \param i \\
    t' &= \CP j {\CP i x z}{\CP i y {w'}}
  \end{align*}
  Then
  \begin{align*}
    \proj i {t'} &= \CP j x y = \proj i t \\
    \proj j {t'} &= \CP i x z = \proj j t \\
    \projp i {t\param j} &= y
  \end{align*}
We continue to reason by deduction:
  \begin{align*}
    w' &= t \param j \param i & \text{By def}\\
    {\CP i y {w'}} &= t\param j & \text{Because $\projp i {t\param j} = y $}  \\
    t'\param j &= t\param j & \text{By def}\\
    t' &= t &\text{Because $\proj j {t'} = \proj j t$} \\
    t' &= \CP i {\CP j x y} {\CP j z w} & \text{By def} \\
    t'\param i &= \CP j z w \\
    t'\param i\param j &= w
  \qedhere
  \end{align*}
\end{proof}
\begin{corollary}
  The types $A \op i \CP j x y \op j z$ and $A \op j \CP i x z \op i y$ are isomorphic.
\end{corollary}

\begin{remark}
  At this point one may wonder if the system could have been set up to have
   $t\param i \param j = t\param j \param i$, and
    the equality between $A \op i \CP j x y \op j z$ and $A \op j
    \CP i x z \op i y$ rather than an isomorphism.
  % \item conversion rules such as $\CP j a b \param i = \CP j {a \param
  %     i}{b \param i}$.
 The answer is that the equation
  $$A \op i \CP j x y \op j z = A \op j \CP i x z \op i y$$  
  is inconsistent: in particular for $A = U$ one gets
  $$U \op i \CP j X P \op j Q = U \op i \CP j X P \op j Q$$
  for arbitrary $P$ and $Q$ of type $U \op i X$.  The above equality
  in turn implies
  $$(x:X) → P x → Q x → U = (x:X) → Q x → P x → U$$
  for arbitrary predicates $P$ and $Q$ over $X$, which is obviously
  inconsistent.
\end{remark}
\begin{theorem}
  If the type $A$ and the term $x$ do not depend on either $i$ or $j$, any proof of $A \op i x$ is related to the canonic proof ($x \param i$).
\end{theorem}
\begin{proof}
  \begin{align*}
    &q   : (A:U) → (x:A) → (x':A \op i x) → A \op i \CP j x {x \param i} \op j x'\\
    &q   : (A:U) → (x:A) → (x':A \op i x) → A \op i x \op j x' &\text {by \fref{cor:equalities}}\\
    &q\, A\, x\, x' = x' \param j
  \qedhere
  \end{align*}
\end{proof}

To conclude the section we note that by iterating parametricity $n$
times, one creates $n$-ary relations, and that the above results carry
over to the $n$-ary case. That is, for each $k < n$, one can construct a function
$\sigma_k$, which exchanges the arguments $k$ and $k+1$ of a
relation. Furthermore, these functions satisfy the laws of the
generators of the symmetric group.

\section{Presheaf model}
\label{sec:model}
In this section we show how to interpret our type-theory by a presheaf model.
Recall \pI{} (\fref{def:pI}), the category of color maps.

  \begin{definition}[Projection]
    We say that a morphism $α : I → I_α$ is a \emph{projection} if $I_α ⊆ I$,$α(i) = 0$
    for each $i ∈ I \backslash I_α$ and $α(i) = i$ for each $i ∈ I_α$.
  \end{definition}
  \begin{definition}[Total maps]
  Injective morphisms, noted $h : I ↣ J$, are the \emph{total} ones, \ie,
  those verifying $h(i) ≠ 0$ for all $i ∈ I$.
  \end{definition}
  \begin{remark}[Morphism decomposition]
  Any morphism $f : I → J$ has a
  unique decomposition into a projection map
  $α : I → I_α$ and a total map $h : I_α ↣ J$.
%  \begin{tikzpicture}[node distance=4\baselineskip]
%    \node              (I)  {$I$};
%    \node[below of=I]  (Ia) {$I_α$};
%    \node[right of=Ia] (J)  {$J$};
%
%    \draw[->] (I) to node[left] {$α$} (Ia);
%    \draw[->] (I) to node[above right] {$f$} (J);
%    \draw[to reversed->] (Ia) to node[below] {$h$} (J);
%  \end{tikzpicture}
  \end{remark}

\begin{definition}[$I$-set]
  We call $I$-element any tuple indexed by the subsets of $I$: $(u_J)_{J ⊆ I}$.
  An $I$-set is a set of $I$-elements.  For instance, the elements of a
  $\{i,j\}$-set are of the form $u = (u_∅,u_i,u_j,u_{i,j})$.
  Alternatively, such an element can be seen as a tuple $(u_α)$ indexed
  by the projections $α : I → I_α$.
\end{definition}
  %
  If $a,b$ are $I$-elements and $j ∉ I$, we define the $(I,j)$-element
  $(a ,_j b)$ as $(a ,_j b)_J ≔ a_J$ if $j ∉ J$ and $(a ,_j b)_{J,j} ≔ b_J$.
  %
  Any $(I,i)$-element can be written $u = (u_J)_{J ⊆ \{I,i\}} = (u_J)_{J ⊆ I} ∪ (u_{J,i})_{J ⊆ I}$;
  We can therefore define the $I$-elements $u (i\,0) ≔ (u_J)_{J ⊆ I}$ and $u · i ≔ (u_{J,i})_{J ⊆ I}$.
  (Hence by definition $u = (u (i\,0) ,_i u · i)$.)

\bigskip
Recall that a \emph{presheaf} $F$ on \pI{} is given by a family of sets $F(I)$ together
with restriction maps $F(I) → F(J)$, $u ↦ uf$ for $f : I → J$
satisfying $u1 = u$ and $(uf)g = u(fg)$. We refine this notion by requiring
two further conditions:
%
\begin{enumerate}
  \item for any $I ∈ \pI$, $F(I)$ is an $I$-set, and
  \item for any projection map $α : I → I_α$, the restriction
    map $F(I) → F(I_α)$, $u ↦ uα$ is the projection operation, \ie,
    $uα_J = u_J$ for any $J ⊆ I$.
\end{enumerate}
%
Seeing an $I$-element $u$ as a tuple indexed by projection maps
$α : I → I_α$, the second requirement can be written $(uα)_β = u_{αβ}$.

\bigskip
A context $Γ ⊢_I$ is interpreted as a presheaf on the slice category
$\pI^\opp/I$, \ie, by a family of $J$-sets $Γf$ for any map $f : I → J$
together with restriction maps $Γ f → Γ fg$, $ρ ↦ ρg$
for $g : J → K$ satisfying the conditions $ρ 1 = ρ$ and $(ρg)h = ρ(gh)$.
Furthermore the map $Γf → Γ(fα)$, $ρ ↦ ρα$ is the projection operation.

\medskip
A type $Γ ⊢_I A$ is interpreted as follows.
For each map $f : I → J$, and $ρ ∈ Γf$ we give a $J$-set $A(f,ρ)$
together with restriction maps $A(f,ρ) → A(fg,ρg)$, $u ↦ ug$ if $g : J → K$
satisfying $u1 = u$ and $(ug)h = u(gh)$ for any $h : K → L$.
Furthermore the map $A(f,ρ) → A(fα,ρα)$, $u ↦ uα$ is the projection operation.

\medskip
A term $Γ ⊢_I a : A$ is interpreted by a $J$-element $a(f,ρ) ∈ A(f,ρ)$
for each $f: I → J$ and $ρ ∈ Γf$, such that
$a(f,ρ)g = a(fg,ρg)$ for any $g : J → K$.

\medskip
If $Γ ⊢_I A$ we define the interpretation of $Γ,x:A ⊢_I$
by taking $⟨ρ,x=u⟩ : (Γ,x:A)f$ to mean $ρ ∈ Γf$ and $u ∈ A(f,ρ)$. The
restriction map is defined by $⟨ρ,x=u⟩g = ⟨ρ g, x=ug⟩$.

\bigskip
The above refinement on presheaves is necessary for the interpretation
of some of our styntactic constructions.  Indeed, without this refinement,
it is not clear how to validate the equality
${{(\CTimes i {x:A} B[x])} \op i a = B[a]}$.

\bigskip
The semantics we define satisfies the substitution law. That is, if $Γ,x:A ⊢_I B$
and $Γ ⊢_I a:A$ then for any $f : I → J$ and $ρ ∈ Γ f$ we have
$B[a](f,ρ) = B(f,⟨ρ,x=a(f,ρ)⟩)$.
It also satisfies the substitution law on colors, \ie, if $Γ ⊢_I A$ and
$f : I → J$ then for any $g : J → K$ we have $Γ'g = Γ(fg)$,
where $Γ'$ is the result of perfoming the substitution $f$ in $Γ$, and if
$ρ ∈ Γfg$ we have $Af (g,ρ) = A(fg,ρ)$.
For establishing these properties, we proceed as in \citet{Aczel98onrelating}.

\bigskip
We proceed to interpret each of the type constructions.
\begin{description}
  \item[\sc Pi.]
    Assume $f : I → J$ and $ρ ∈ Γf$. We define $((x:A) → B)(f,ρ)$ as a $J$-set.
    A $J$-element of $((x:A) → B)(f,ρ)$ is defined as a tuple $λ = (λ_α)$,
    where each $λ_α$ is a family of elements indexed by a total map $g : J_α ↣ K$:
    $$λ_{α g} ∈ \prod_{u ∈ A(fα g,ραg)} B(fαg,⟨ραg,x=u⟩)$$
    such that
    $\app{λ_{αg}}{u} h = \app{λ_{α gh}}{uh}$ for $g : J ↣ K$ total and \emph{any} $h : K → L$.
    Because any map $J → K$ has an unique decomposition as a projection and a total
    map, we can consider $λ_h$ for an arbitrary map $h : J → K$.

    If $g : J → K$ is an arbitrary map, we define $λ g$ to be the tuple
    $(λ g_β)$ where $λ g_β$ is the family $λ g_{βh} = λ_{gβh}$.

    With such a definition, we directly have $λα_{β} = λ_{αβ}$.

    This is similar to the usual interpretation of dependent product in
    presheaf models \citep{Hofmann97syntaxand,bezem2014model} except that we
    have to present each element as a tuple, which can be done in a natural way.


  \item[\sc Universe.]
    The universe $U$ is interpreted as a presheaf over \pI. An element $A$ of
    $U(I)$ is a tuple $(A_α)$ where each $A_α$ is a family of sets
    $A_{α f}$ for $f : I ↣ J$ \emph{total} together with restriction
    maps $A_{α f} → A_{α fg}$, $u ↦ ug$ for $f : I ↣ J$ total
    and $g : J → K$ arbitrary, such that $u1 = u$ and $(ug)h = u(gh)$.

    As before, such a data defines a set $A_f$ for an arbitrary map $f : I → J$
    with restriction maps $A_f → A_{fg}$ if $g : J → K$.

    If $g : I → J$ is an arbitrary map, we define $Ag$ by taking $Ag_{βh}$
    to be the set $A_{gβh}$, together with restriction maps $Ag_{βh} → Ag_{βhl}$
    defined as the given maps $A_{gβh} → A_{gβhl}$.

    We can then check, as before, that we have $Aα_{β} = A_{αβ}$

    This is similar to the usual interpretation of universe in
    presheaf models \citep{Hofmann97syntaxand,bezem2014model} except that we
    have to present each element as a tuple, which again can be done in a natural way.


  \item[\sc Out.]
    Assume $f : I → J$ and assume $ρ ∈ Γf$.  We need to define the $J$-set $(P \op {i} a)(f,ρ)$.
    Let $j = \fresh J$ and $ι_i : I → I,i$, $ι_j : J → J,j$ the inclusions.
    We can consider the $J,j$-set $P(f^{ij},ρι_i)$, and $a(f,ρ)$ a ($J$-)element of
    $P(i\,0)(f,ρ) = P((i\,0)f,ρ) = P(ι_i f,ρι_j)(j\,0)$.
    We define $(P \op {i} a)(f,ρ)$ to be the set of $J$-elements $v$ such that
    $(a(f,ρ),_j v) ∈ P(ι_i f,ρι_j)$. If $v$ is such an element and $g : J → K$
    and $k=\fresh K$, then $vg$ is defined by the equation
    $(a(f,ρ)g,_k vg) = (a(f,ρ)g,_k v) g^{jk}$.


  \item[\sc In-Pred.]
    Assume $f : I,i → J$, and $ρ ∈ Γ(ι_if)$.  We need to define the $J$-set
    $(\CTimes i {x:A} B)(f,ρ)$.
    Let $ι_i : I → I,i$ be the inclusion. There are two cases. If $f(i) = 0$,
    then $(\CTimes i {x:A} B)(f,ρ)$ is defined to be the $J$-set $A(ι_i f)$.
    Otherwise, if $f(i) = j ∈ J$, then we define $(\CTimes i {x:A} B)(f,ρ)$ to
    be the $J$-set of $(u,_j v)$ where $u$ is a $J\backslash\{j\}$-element in
    $A(ι_i f(j\,0),ρ(j\,0))$ and $v$ is an element in
    $B(ι_i f(j\,0),⟨ρ(j\,0),x=u⟩)$.


  \item[\sc Decode.]
    Assume $f:I → J$ and $ρ ∈ Γf$.  We have $A(f,ρ) ∈ U(J)$ and we define
    $\El{A}(f,ρ)$ to be the set $A(f,ρ)_1$.
    The restriction map $\El{A}(f,ρ) → \El{A}(fg,ρ g)$, $u ↦ ug$ is defined
    using the restriction map $A(f,ρ)_1 → A(f,ρ)_g$ and the fact that we have
    $A(f,ρ)_g = A(fg,ρ g)_1$.
\end{description}

\begin{remark}
  Our calculus does not have any base type, but they could be interpreted
  by modifying their usual interpretation as a constant presheaf into an
  isomorphic $I$-set.
  For instance, the base type of natural numbers would be interpreted as
  the $I$-set of $(n_J)_{J ⊆ I}$ where $n_∅ ∈ ℕ$ and $n_J = 0$ for any
  non-empty $J ⊆ I$.
\end{remark}

\bigskip
We now describe how to interpret terms.
\begin{description}
  \item[\sc Var.]
    We define $x(f,ρ)$ to be $ρ(x)$

  \item[\sc Lam.]
    We define $\app{(λ x:A.b)(f,ρ)_{α f}}{u}$ to be $b(f,⟨ρα f,x=u⟩)$

  \item[\sc App.]
    We define $(t\,u)(f,ρ)$ to be $\app{t(f,ρ)_1}{u(f,ρ)}$

  \item[\sc In-Abs.]
    Let $f:I,i → J$ and $ρ ∈ Γι_i f$ be given.
    We define $(a ,_i p)(f,ρ)$ by case on $f(i)$.
    If $f(i) = 0$, we take $(a,_ip)(f,ρ)$ to be $a(ι_i f,ρ)$.
    If $f(i) = j ∈ J$, we take $(a,_ip)(f,ρ)$ to be $(a(ι_if(j0),ρ),_j p(ι_if(j0),ρ))$

  \item[\sc In-Fun.]
    Let $f:I,i → J$ and $ρ ∈ Γι_i f$ be given.
    We define ${\fp i t u}(f,ρ)_g$ by case on $g(f(i))$.
    If $g(f(i)) = 0$, we take ${\fp i t u}(f,ρ)_g$ to be $t(ι_i f,ρ)_g$.
    If $g(f(i)) = j ∈ K$, we define $w = {\fp i t u}(f,ρ)_g$ by
    $$\app{w}{(a ,_j b)} =
      ( \app{t\,(ι_i fg(j0),ρ g(j0))}{a}
      ,_j
        {\app{\app{u\,(ι_i fg(j0),ρ g(j0))}{a}}{b}}
      )$$

  \item[\sc Color-Elim.]
    Let $f:I → J$ and $ρ ∈ Γ f$ be given.
    We define $(a \param i)(f,ρ)$ to be $a(f^{ij},ρι_j)\param j$
    where $j = \fresh{J}$.
\end{description}

\begin{theorem}[Convertible terms are semantically equal]
  \label{thm:convertible-in-model}
  If $Γ ⊢_I a : A$ and $Γ ⊢_I b : A$ with $a = b$, then
  $a(f,ρ) = b(f,ρ)$ for any $f : I → J$ and $ρ : Γf$.
  In particular,
  \begin{itemize}
    \item $\app{λt}{u}(f,ρ) = t[u](f,ρ)$,
 %     where $[u]$ is the map $Γ → Γ.A$, $[u]ρ ↦ ⟨ρ,uρ⟩$
    \item $({(\CTimes i {x:A} B)} \op {i} a)(f,ρ) = B(f,⟨ρ,x=a(f,ρ)⟩) = B[a] (f,ρ)$
  \end{itemize}
\end{theorem}
\begin{proof}
  \todo{We prove only so and so cases, the rest are similar or straightforward.}
  Let $f : I → J$, $j = \fresh J$, $g = (f,i=j): I,i → J,j$. We have
  We have
  \begin{align*}
    ({((x:A)\times_i B)} \op {i} a)(f,ρ)
    &= \left\{ v \mid (a(f,ρ) ,_j v) ∈ (\CTimes i {x:A} B)g \right\}
    \\
    &= \left\{ v \mid (a(f,ρ) ,_j v) ∈ \left\{ (u ,_j w) \mid u ∈ A(f,ρ), w ∈ B(f,⟨ρ,x=u⟩) \right\} \right\}
    \\
    &= \left\{ v \mid v ∈ B(f,⟨ρ,x=a(f,ρ)⟩) \right\}
    \\
    &= \left\{ v \mid v ∈ B[a](f,ρ) \right\}
    \\
    &= B[a](f,ρ)
  \qedhere
  \end{align*}
\end{proof}

\todo{Remark: \LaTeX-ify the proof that
  $(U \op i (A,_j P) \op j Q)f ≠ (U \op j (A,_jQ) \op i Q)f$,
  and explain why.
}


\begin{theorem}[Validity]
  If $Γ ⊢_I a : A$, $f : I → J$, $ρ ∈ Γf$, then $a(f,ρ) ∈ A(f,ρ)$.
%  Furthermore $af(1,ρ) = a(f,ρ)$ (using the interpretation of
%  $Γf ⊢_J af : Af$).
\end{theorem}
\begin{proof}
  By induction on the typing judgement.  We only prove the cases \textsc{In-Abs} and \textsc{Color-Elim}.  \textsc{In-Fun} is similar to the former, and the other
  cases match the usual proof (using \fref{thm:convertible-in-model} for \textsc{Conv}).
  \begin{description}
    \item[\sc In-Abs.]
      Let $f : I,i → J$ and $ρ ∈ Γf$.
      We need to show that $(a ,_i p)(f,ρ) : T(f,ρ)$.
      If $f(i) = 0$, we have by definition $(a,_ip)(f,ρ) = a(ι_i f,ρ)$,
      which by induction hypothesis belongs to the $J$-set $T(i\,0)(ι_i f,ρ)$;
      but by color substitution $T(i\,0)(ι_i f,ρ) = T((i\,0)ι_i f,ρ) = T(f,ρ)$.
      If $f(i) = j ∈ J$, we have $f = g^{ij}$ where $g = ι_if(j\,0)$; by induction
      hypothesis $p(g,ρ) ∈ (T \op i a)(g,ρ)$ hence by definition
      $(a(g,ρ) ,_j p(g,ρ)) ∈ T(g^{ij},ρι_j)$ then
      $(a ,_i p)(f,ρ) ∈ T(f,ρ)$.

    \item[\sc Color-Elim.]
      Let $f : I → J$ and $ρ ∈ Γf$.
      We need to show that $(a \param i)(f,ρ) ∈ (T \op i {a(i\,0)}) (f,ρ)$, \ie,
      that
      $ (a(i\,0)(f,ρ) ,_j (a \param i)(f,ρ))
      = (a((i\,0)f,ρ) ,_j a(f^{ij},ρι_j) · j)
      ∈ T(f^{ij},ρι_j)$
      where $j = \fresh J$.
      By induction hypothesis $a(f^{ij},ρι_j) ∈ T(f^{ij},ρι_j)$, and since it is a
      $(J,j)$-element we have
      $a(f^{ij},ρι_j) = (a(f^{ij},ρι_j)(j\,0) ,_j a(f^{ij},ρι_j) · j)$
      We conclude by remarking that $a(f^{ij},ρι_j)(j\,0) = a((i\,0)f,ρ)$ holds
      by color substitution and definition of $f^{ij}$.
    \qedhere
  \end{description}

\end{proof}

\section{Related Work}

\subsection{Our own line of work}
This work continues a line of work aiming at a smooth integration of
parametricity with dependent types
\citep{bernardy_parametricity_2010,bernardy_realizability_2011,bernardy_proofs_2012,bernardy_computational_2012,bernardy_type-theory_2013}. The present work offers two improvements over previous publications:
1. a denotational semantics, and
2. a much simplified syntax, suitable as the basis of a proof assistant.

The simplification of syntax is allowed by foregoing the preservation
of functions by parametricity. We call preservation of functions by
parametricity the property that if $f$ were a function, then the
canonical proof that $f$ is parametric (denoted $f \param i$ here) is
also a function. To our knowledge, following \citet{reynolds_types_1983}, all parametric \emph{models} of parametricity (both syntactical and semantical ones) have this property.
However, having this property in the \emph{syntax} implies that
certain function arguments must be swapped when performing the
substitution of beta reduction, as identified by
\citet{bernardy_computational_2012}.  In the present system, the
parametric interpretation of functions is instead merely isomorphic to
a function, thanks to the {\sc In-Fun} rule (\fref{thm:iso-fun}). This
isomorphism (rather than equality) means on the one hand that the
swapping of arguments is handled by the usual rules of logic, instead
of special-purpose ones. On the other hand, obtaining the classical
parametric interpretation of types requires some purely mechanical
work by the user of the logic.

\subsection{Parametric Models of Type-Theory vs. Parametric Type-Theories}

Two pieces of work propose alternative parametric models of
type-theory
\citep{atkey_relationally_2014,krishnaswami_internalizing_2013}, but
do not integrate parametricity in the syntax of the calculus. This
means that, while certain consequences of parametricity can be made
available in the logic, via constants validated by the model,
parametricity itself is not available. In this paper, we not only
propose a parametric model, but also show how it can be used to
interpret parametricity straight up in the syntax of the type-theory.


\subsection{Various kinds of models}
Another characterising feature of proposals for parametricity is the
kind of model underlying the
semantics. \Citet{krishnaswami_internalizing_2013} propose a model
based on Q-PER. \Citet{atkey_relationally_2014} propose a model based
on reflexive graphs. The model that we use is based on cubes
(functions from subsets of colors). In
our 2012 work the cubes were reified as syntax in
an underlying calculus, while in the present work they refine a presheaf structure.

\subsection{Presheaf models}

The presheaf construction used in this paper follows a known template,
used for example by \citet{bezem2014model,DBLP:journals/corr/Pitts14}
to model univalence in type-theory. Not only both models use a
presheaf, but they also have the same underlying category $\pI$.
This means as all these models have an additional cubical structure.
We find remarkable that cubical structures are useful for modeling both
parametricity and univalence.
\cite{altenkirch2014syntax} give a syntax for
\citeauthor{bezem2014model}'s Cubical Type Theory, effectively modelling
univalence by internalization of their model.
The present work further refines the model by interpreting terms as
$I$-elements, which is essential to interpret our special-purpose
pairing constructions.

\section{Future work and conclusion}
We have defined a new type-theory with internalised parametricity.
Thanks to our model construction, we have proved the consistency of
the system. The missing piece to construct a type-checker is a
decision algorithm for the conversion relation.  This checker could
then be used as a minimal proof assistant for a type-theory with
parametricity.

\bibliographystyle{abbrvnat}
\bibliography{PaperTools/bibtex/jp,tt}

\end{document}
