\documentclass[english]{PaperTools/latex/lipics}
\graphicspath{{PaperTools/latex/}}
\usepackage{natbib}
\usepackage[utf8]{inputenc}
\usepackage{stmaryrd}
\usepackage{amssymb,amstext,amsmath}
\usepackage{mathtools}
\usepackage{mathpartir}
\usepackage{fancyref}
\usepackage{todonotes}
\input{fancyrefs}
\usepackage{tikz}
\usetikzlibrary{arrows}

\newcommand\CC[4]{(#2,_{#1} #3)}
\newcommand\CP[3]{(#2,_{#1} #3)}
\newcommand\CTimes[2]{(#2) ×_{#1}}
\newcommand\SW[2]{\mathsf{SW}^{#1}_{#2}}
\newcommand\sw[2]{\mathsf{sw}^{#1}_{#2}}
\newcommand\dom{\mathsf{dom}}
\newcommand\param[1]{\!\cdot\!#1}
\newcommand\pvar[2]{{#1}^{(#2)}}
\newcommand\op[1]{∋_{#1}}
\newcommand\ip[3]{Σ^{#1} {#2}\,{#3}}
\newcommand\fp[3]{⟨#2 ,_{#1} #3⟩}
\newcommand\mor[2]{({#1}\,{#2})}
\newcommand\proj[2]{{#2}\,\mor{#1}0}
\newcommand\projp[2]{\proj{#1}{(#2)}}

\newcommand\comment[1]{}
\input{unicodedefs}

\def\pI{\ensuremath{\mathbf{pI}}}
\def\fresh#1{\mathsf{fresh}(#1)}
\def\Hom#1#2{\mathbf{Hom}(#1,#2)}
\def\ie{\textit{i.e.}}
\def\app#1#2{\mathsf{app}(#1,#2)}
\def\El#1{\mathrm{El}(#1)}
\def\opp{\mathrm{op}}

\title{A presheaf model of parametric type-theory}

\author{}
\date{\today}

\begin{document}
\maketitle

\begin{abstract}
  We propose a new type-theory with internalized
  parametricity. Compared to previous similar proposals, this version
  comes with a denotational semantics which is a refinement of the
  standard presheaf semantics of dependent type theory. Further, this
  presheaf semantics is a refinement of the one used to interpret
  nominal sets with restriction.  This calculus is a candidate for the
  core of a proof assistant with internalized parametricity.
\end{abstract}

\section{Introduction}
In lambda-calculi, every type can be interpreted as a predicate, which
its inhabitants are guaranteed to satisfy.
%
A simple example is that if a function $f$ has type $(A : U) → U → U$ ---
the type of the polymorphic identity --- then the following
proposition holds:
%
\[
  (A : U) → (P : A → U) → (x : A) → P x → P (f A x)
\]
%
(which implies that $f$ must return exactly its argument).
The above result, \emph{abstraction}, has proved useful for reasoning
about functional programs \citep{wadler_theorems_1989}. It also has deep
theoretical implications: for example, the induction principle over Church numerals
can be deduced from it \citep{wadler_girardreynolds_2007}.


The abstraction theorem is an invention of
\citet{reynolds_types_1983}, which he used to give formal meaning to
polymorphism in the λ-calculus. He does so by a model construction
where types are interpreted as predicates and functions are interpreted
by predicate-preserving functions.

In this paper, we propose an extension of Reynolds' model, where a
type is interpreted as a hypercube of sets, predicates, relations,
relations between relations and so on. Our model
supports the interpretation dependent type-theories, and of
parametricity itself (parametricity is parametric).  We take advantage of this
closure property by intergrating parametricity into the syntax of the
type-theory being interpreted.  This means that the user of the logic
can prove any parametricity result directly in the logic, rather than
having to resort to an external semantic justification.

Our technical contributions are as follows:
\begin{itemize}
\item We propose a novel type-theory (\fref{sec:syntax}), and show
  that it internalises parametricity (\fref{sec:parametricity}).
  % In particular, we show that the calculus internalizes parametricity. 
  % in \fref{sec:abstraction}. \comment{Much of this is now in the appendix...}
\item We provide a presheaf model for this type-theory.
      This model is refinement of the presheaf semantics used to
      interpret nominal sets with
      restrictions~\citep{bezem2014model,DBLP:journals/corr/Pitts14}.
\end{itemize}

\section{Syntax}
\label{sec:syntax}
In the following section we define the syntax and typing-rules of our
parametric type-theory, as well as the equality judgement.

We consider a special symbol ‘0’ and assume a countable infinite set of other
symbols, called \emph{colors}.
The metasyntactic variables $i,j,\ldots$ range over colors, while
$I,J,…$ range over \emph{finite} sets of colors.
We suppose a fixed \emph{gensym} function $\fresh{·}$ such that
$\fresh{I} ∉ I$ for any finite color set $I$.

Compared to type-theory, the main innovation of the type-theory
presented here is that terms may depend on (a finite number of)
colors.
\begin{definition}[Syntax of terms and contexts]
  \begin{align*}
    t,u,A,B & \coloneqq x & \text {variable} \\
            & \mid U & \text{universe} \\ 
            & \mid |A| & \text{code} \\ 
            & \mid El(A) & \text{decode} \\ 
            & \mid λx:A. t & \text{abstraction} \\
            & \mid t u & \text{application} \\ 
            & \mid (x:A) → B & \text{product} \\
            & \mid \CP i t u & \text{colored pair} \\
            & \mid \CTimes i {x:A} B  & \text{colored type pair} \\
            & \mid \fp i t u & \text{colored function pair}\\
            & \mid A \op i u & \text{parametricity type} \\
            & \mid t \param i & \text{parametricity proof} \\
    \Gamma,\Delta & \coloneqq () \mid \Gamma,x:A
  \end{align*}
\end{definition}

\begin{itemize}
\item Each color $i$ may be erased from a term $a$ to obtain a realiser, written $\proj i a$ (detailed in \fref{def:color-subst}).
\item the type $A \op i u$, which expresses that $u$ satisfies the
  parametricity predicate associated with the type $A$ on color $i$.
\item the term $a \param i$, which yields a proof of $A \op i \proj i a$.
\item the forms $\CP i t u$, $\CTimes i A B$ and $\fp i t u$ allow to
  locally associate parametricity proofs with a given realizer.
\end{itemize}



\begin{definition}[Typing judgements — à la Tarski]
We mutually define three judgments:
\begin{itemize}
\item $Γ⊢_I$ (Is the context $Γ$ is well-formed, assuming the color set $I$?).
\item $Γ⊢_I A$  (Is the type $A$ well-formed in $Γ$ and assuming the color set $I$?)
\item $Γ⊢_I a : A$  (Does the term $a$ have type $A$ in the context $Γ$ and assuming the color set $I$?)
\end{itemize}

\fbox{$Γ⊢_I$}
  \begin{mathpar}
    \inferrule[Empty]{~}{() ⊢_I }

    \inferrule[NewVar]{Γ⊢_I \\ Γ ⊢_I A }{ Γ,x:A ⊢_I }

  \end{mathpar}
 
\fbox{$Γ⊢_I A$}
 \begin{mathpar}

    \inferrule[Universe]{~}{Γ ⊢_I U}

    \inferrule[Decode]{Γ ⊢_I A : U}{Γ ⊢_I \El{A}}
    \\
    \inferrule[Pi]{Γ ⊢_I A \\ Γ,x:A ⊢_I B}{Γ ⊢_I (x:A) → B}

    \inferrule[Out]{Γ ⊢_{I,i} T \\ Γ ⊢_I a : \proj i T}{Γ ⊢_I T \op i  a}

    \inferrule[In-Pred]{Γ ⊢_{I} A \\ Γ,x:A ⊢_{I} B}{Γ ⊢_{I,i} \CTimes i {x:A} B}
 \end{mathpar}

\fbox{$Γ⊢_I a : A$}
  \begin{mathpar}
    \inferrule[Conv]{Γ ⊢_I t:A \\ A = B}{Γ ⊢_I t : B}

    \inferrule[Var]{Γ ⊢_I \\ x : A ∈ Γ}{Γ ⊢_I x : A}

    \inferrule[Code]{Γ ⊢_I A }{Γ ⊢_I |A| : U}

    \\\inferrule[Lam]{Γ,x:A ⊢_I B}{Γ ⊢_I λx:A.b : (x:A) → B}
 
    \inferrule[App]{Γ ⊢_I t : (x:A) → B[x] \\ Γ ⊢_I u : A}{Γ ⊢_I t u: B[u]}

    \\\inferrule[In-Abs]{Γ ⊢_I a : \proj i T \\Γ ⊢_I p : T \op i a}{Γ ⊢_{I,i} \CP i a p : T}

    \inferrule[In-Fun]
        {Γ ⊢_I f : \projp i {(x:A) → P x}\\\\
        Γ ⊢_I g : (x:\proj i A) → (x':A \op i x) → P \CP i x {x'} \op i f x}{Γ ⊢_{I,i} \fp i f g : (x:A) → P x}

    \inferrule[Color-elim]{Γ ⊢_{I,i} a : T}{Γ ⊢_I a \param i : T \op i {\proj i a}}
  \end{mathpar}
\end{definition}

The parametricity constructions ($·$ and $∋$) act like color
binders (they bring colors into scope), while the pairing constructs
remove colors from scope.
The equality relation used in the {\sc Conv} rule is detailed below in \fref{def:conversion}.

Additionally, for the above system to be well-founded, we need to
distinguish small and big types, and allow only small types to be
encoded in $U$. Small types are closed under product, $×_i$ and
$∋_i$. The distinction between big and small types being standard, and
to keep the presentation concise, we leave it implicit in the syntax.

% 'Morphism' means something only in the context of a category; hence Morphism application ==> Color substitution
\begin{definition}
  A \emph{color map} $f : I → J$ is a function $I → J ∪ \{0\}$ such that
  $f(i_1) = f(i_2)$ iff $i_1 = i_2$ whenever $f(i_1) = f(i_2) ∈ J$.
%
  If $f : I → J$ and $g : J → k$, we define the composition $fg : I → K$
  as $fg(i) = 0$ if $f(i) = 0$ and $fg(i) = g(f(i))$ if $f(i) ∈ J$.
  We note $1_I : I → I$ the identity map: $1_I(i) = i$ for each $i ∈ I$;
  we note $(i\,0) : I,i → I$ the partial identity: $(i\,0)(i) = 0$ and
  $(i\,0)(j) = j$ for each $j ∈ I$;
  and $η_i : I → I,i$ the canonical injection: $η_i(i) =i$ for all $i ∈ I$.
%
  Furthermore for each color map $f : I → J$, $i ∉ I$ and $j ∉ J$, we
  note $f^{ij} : I,i → J,j$ the color map such that
  $f^{ij}(i) = j$ and $f^{ij}(k) = f(k)$ for all $k ∈ I$.
\end{definition}
\begin{definition}[Color substitution]~
  \label{def:color-subst}
  We consider a color map $f : I → J$ as a (color) substitution on terms,
  and define $af$ by structural induction on $a$.
\begin{align*}
  x f & = x \\
  U f & = U \\
  (λ(x:A).t) f &= λ(x:Af).tf \\
  (t\,u) f &= (tf) \, (uf) \\
  ((x:A)→B) f &= (x:Af)→(Bf) \\
  \CP {i} a p f &= \CP {j} {ag} {pg}
    & \text{if $f(i) = j ∈ J$, where g = $η_i f (j\,0)$} \\
    &= a(η_if)
    & \text{if $f(i) = 0$} \\
  (A ×_i B) f &= \CTimes {j} {Ag} {(Bg)}
    & \text{if $f(i) = j ∈ J$, where g = $η_i f (j\,0)$} \\
    &= A(η_if)
    & \text{if $f(i) = 0$} \\
  \fp {i} u v f &= \fp {j} {ug} {vg}
    & \text{if $f(i) = j ∈ J$, where g = $η_i f (j\,0)$} \\
    &= u(η_if)
    & \text{if $f(i) = 0$} \\
  (A \op {i} a) f &= (Af^{ij}) \op {j} (af)
    & \text{where $j = \fresh J$} \\
  (a · i) f &= (af^{ij}) · j
    & \text{where $j = \fresh J$} \\
  \\[.33\baselineskip]
  () f      &= () \\
  (Γ,x:A) f &= Γ f, x : A f
\end{align*}
\end{definition}

\begin{theorem}~
  \begin{itemize}
  \item $a1_I = a$
  \item $(af)g = a(fg)$ for any $f: I → J$ and $g : J → K$
  \end{itemize}
\end{theorem}
\begin{proof}
  By structural induction on $a$.
\end{proof}

\begin{theorem}[Color substitution preserves typing]
  If $Γ ⊢_I a : A$ then the term
$af$ is defined and $Γ f ⊢_J af : Af$
\end{theorem}
\begin{proof}
  By induction on the typing judgement.
\end{proof}

\comment{
\begin{definition}[Normal forms and neutral terms]~
  \begin{align*}
    \mathsf{Nf} ∋ u,v,A,B & \coloneqq
      U \mid λx:A. t \mid (x:A) → B \\
      & \mid \CP i u v \mid \fp i u v \\
      & \mid {(\CTimes {i₀} A B)} \op {i₁} {u_1 \cdots} \op {i_n} {u_n} &\quad \text{($i₀ \prec i₁ \prec \ldots \prec i_n$)} \\
      & \mid s \param {i₀} \cdots \param {i_{n-1}}                  &\quad \text{($i₀ \prec   < \ldots \prec i_{n-1}$)}
    \\
    \mathsf{Ne} ∋ s & \coloneqq x \mid s \, u
  \end{align*}
\end{definition}
}

\begin{definition}[Conversion]~
\label{def:conversion}
The convertibity of types used in the {\sc Conv} rule is defined
inductively by the following rules.
\begin{mathpar}
  \inferrule[Pair-App]{}{{\fp i f g} \, a      = (f\,{\proj i a} ,_i g\,{\proj i a}\,{(a \param i)})}
\and
  \inferrule[Pair-Param]{}{{(a,_i p)}\param i   = p}
\and
  \inferrule[Pair-Pred]{}{{(\CTimes i {x:A} B[x])} \op i a = B[a]}
\and
    \inferrule{}{\El{|A|} = A}
\and
    \inferrule{}{|\El{A}| = A}
\and
    \inferrule[β]{}{(λx:A. u[x]) t = u[t]}
\and
    \inferrule[η]{t x = u} {t = λ x:A.u}
    \and
    \inferrule[Surj-Param]{\proj i t = a \\ t \param i = p} {t = \CP i a p }
    \and
    \inferrule[Surj-Fun]{\proj i t = f \\ (t \CP i x y) \param i = g x y} {t = \fp i f g }
    \and
    \inferrule[Surj-Typ]{\proj i T = A \\ T \op i x = B} {T = \CTimes i {x:A} B }
    \and
    \inferrule[Refl]{~}{a = a}
    \and
    \inferrule[Sym]{a = b}{b = a}
    \and
    \inferrule[Trans]{a = b \\ b = c}{a = c}
  \end{mathpar}
Additionally, all congruences yield convertibity rules.
\end{definition}


\begin{corollary}~
  \label{cor:equalities}
  \begin{itemize}
  \item $a = \CP i {\proj i a} {a \param i}$
  \item $T = \CTimes i {x:\proj i T} {(T \op i x)}$
  \item $f = \fp i {\proj i f} {λx x'. (f \CP i x {x'}) \param i}$
  \end{itemize}
\end{corollary}

\section{Parametricity}
\label{sec:parametricity}

Contrary to previous type theories with internalized parametricity
\citep{bernardy_computational_2012, bernardy_type-theory_2013}, the
system presented here lacks equalities which allow to compute
parametricity types. Expressed in our syntax, those equalites would become the conversion rules:
$$U \op i A = A → U$$
and
$$((x:A) → B[x]) \op i f = (x:A) → (x' : A \op i x) → B[\CP i x {x'}] \op i (f x).$$

The absence of the above equalities allows for a simpler system, but
how can we ensure that all parametricity theorems hold?  The answer is
that we provide the above relationships as isomorphisms.

We say that $A$ is isomorphic to $B$ iff.
\begin{enumerate}
  \item There exist $f : A → B$
  \item There exist $g : B → A$
  \item For any $x$, $f\, (g\, x) = x$
  \item For any $x$, $g\, (f\, x) = x$
\end{enumerate}
This notion of isomorphism is quite strong, because the equality
used in its definition is the conversion relation (defined in
\fref{def:conversion}).

\begin{theorem}
\label{thm:iso-univ}
$U \op i A$ is isomorphic to $A → U$.
\end{theorem}
\begin{proof}~
  \begin{enumerate}
  \item
    $\begin{array}[t]{l@{\,}l@{\,}l}
      f : (&Q : U \op i A) → &A → U \\ 
      f & Q &x = \CP i A Q \op i x
    \end{array}$
  \item
    $\begin{array}[t]{r@{\,}l}
      g &: (P : A → U) → U \op i A\\
      g &P = (\CTimes i {x:A} (P x)) \param i
    \end{array}$
  \item $\CP i A {(\CTimes i {y:A} (P y)) \param i} \op i x = (\CTimes i
    {y:A} (P x) \op i x = P x$ By $η$-contraction we get the desired result.
  \item $(\CTimes i {x:A} {\CP i A Q \op i x}).i = Q$ if $\CTimes i {x:A} {\CP i A Q \op i x} = \CP i A Q$. We then use equality for $×_i$. The first components are obviously equal. For the second components we are left with $\CP i A Q \op i x = \CP i A Q \op i x$, which holds by reflexivity.
  \qedhere
  \end{enumerate}
\end{proof}

\begin{theorem}
\label{thm:iso-fun}
$((x:A) → B[x]) \op i f$ is isomorphic to $(x:A) → (x' : A \op i x) → B[\CP i x {x'}] \op i {(f\, x)}$.
\end{theorem}
\begin{proof}~
  \begin{enumerate}
  \item $\begin{array}[t]{r@{\,}l}
      f &: (q : ((x:A) → B[x]) \op i f) → (x:A) → (x' : A \op i x) → B[\CP i x {x'}] \op i {(f x)}\\
      f &q\, x\, x' = (\CP i f q \CP i x {x'}) \param i
    \end{array}$
  \item $\begin{array}[t]{r@{\,}l}
      g &: ((x:A) → (x' : A \op i x) → B[\CP i x {x'}] \op i (f\,x)) →  ((x:A) → B[x]) \op i f\\
      g & p= \fp i f p \param i
    \end{array}$
  \item $(\CP i f {\fp i f p \param i} \CP i x x') \param i = ({\fp i
      f p} \CP i x {x'}) \param i = \CP i {f\, x} {p\, x\, x'} \param i = p\, x\, x'$
  \item $\fp i f {λx x'. (\CP i f q \CP i x {x'}) \param i} \param i$
    iff $\fp i f {λx x'. (\CP i f q \CP i x {x'}) \param i} = \CP i f
    q$, which is true by the equality rule for function pairing.
  \qedhere
  \end{enumerate}
\end{proof}

In practice, when carrying out parametricity proofs, many of the steps
of the above isomorphisms cancel each other and one obtains a simpler
proof. This property is illustrated by the following example:
parametricity for Church-encoded natural numbers.
(For the sake of simplicity, in the remainder of this section, we leave out the
distinction between types and their codes.)
\begin{example}
Let $N = ∀X. X → (X → X) → X$.
Proving (unary) parametricity for $N$ means that, assuming
\begin{itemize}
\item $f : N$
\item $A : U$
\item $P : A → U$
\item $z : A$
\item $z' : P z$
\item $s : A → A$
\item $s' : (x:A) → P x → P (s x)$
\end{itemize}
we can prove $P (f A z s)$.

Indeed, a proof term is the following:
%
\[
(f (\CTimes i {x:A} (P x)) \CP i z {z'} \fp i s {s'}) \param i
\]
\end{example}

\subsection{Iterating Parametricity}
In our system, one can use parametricity generically as follows:
\begin{align*}
p &: (A:U) → (x:A) → A \op i x\\
p\, x &= x\param i
\end{align*}
We have already seen that $A \op i $ corresponds to the parametricity
predicate for type $A$. We can iterate this operator to construct
relations. That is, given
\begin{align*}
  x & :A \\
  y & : A \op i x\\
  z & : A \op i x
\end{align*}
Then the type $A \op i \CP j x y \op j z$ is well formed ($∋$ is left
associative), and can be understood as a relation
between the parametricity proofs $y$ and $z$. We have the following results on those relation.
\begin{theorem}
If the type $A$ does not depend on either $i$ or $j$, the relation $λy z. A \op i \CP j x y \op j z$ is symmetric.
\end{theorem}
\begin{proof}
  We first construct the proof term:
  \begin{align*}
    &s : (x:A) → (y : A \op i x) → (z : A \op i x) → (w : A \op i \CP j x y \op j z) → A \op j \CP i x z \op i y \\
    &s\, x\, y\, z\, w = \CP i {\CP j x y}{\CP j z w} \param j \param i
  \end{align*}
  And, by α-equivalence, $A \op j \CP i x z \op i y = A \op i \CP j x z \op j y$.
\end{proof}

\begin{theorem}
  As defined above, function $s$ is involutive in its last argument:
  \[ s\, x\, y\, z\, (s\, x\, y\, z\, w) = w \]
\end{theorem}
\begin{proof}
  Let
  \begin{align*}
    t &= \CP i {\CP j x y}{\CP j z w} \\
    w' &= t \param j \param i \\
    t' &= \CP j {\CP i x z}{\CP i y {w'}}
  \end{align*}
  Then
  \begin{align*}
    \proj i {t'} &= \CP j x y = \proj i t \\
    \proj j {t'} &= \CP i x z = \proj j t \\
    \projp j {t  \param i} &= z
  \end{align*}
We continue to reason by deduction:
  \begin{align*}
    w' &= t \param j \param i & \text{By def}\\
    {\CP i y {w'}} &= t\param j & \text{Because $\projp i {t\param j} = y $}  \\
    t'\param j &= t\param j & \text{By def}\\
    t' &= t &\text{Because $\proj j {t'} = \proj j t$} \\
    t' &= \CP i {\CP j x y} {\CP j z w} & \text{By def} \\
    t'\param i &= \CP j z w \\
    t'\param i\param j &= w
  \qedhere
  \end{align*}
\end{proof}

\begin{corollary}
  The types $A \op i \CP j x y \op j z$ and $A \op j \CP i x z \op i y$ are isomorphic.
\end{corollary}
\begin{theorem}
  If the type $A$ and the term $x$ do not depend on either $i$ or $j$, any proof of $A \op i x$ is related to the canonic proof ($x \param i$).
\end{theorem}
\begin{proof}
  \begin{align*}
    &q   : (A:U) → (x:A) → (x':A \op i x) → A \op i \CP j x {p A x} \op j x'\\
    &q   : (A:U) → (x:A) → (x':A \op i x) → A \op i \CP j x {x \param i} \op j x'& \text {by def.}\\
    &q   : (A:U) → (x:A) → (x':A \op i x) → A \op i x \op j x' &\text {by \fref{cor:equalities}}\\
    &q\, x\, x' = x' \param j
  \qedhere
  \end{align*}
\end{proof}

To conclude the section we note that by iterating parametricity $n$
times, one creates $n$-ary relations, and that the above results carry
over to the $n$-ary case in a straightforward manner.
\section{Presheaf model}

\begin{definition}
  Let \pI{} be the category of finite color sets $I,J,K,…$ and color
  maps \cite[ex.~9.7 p.~176]{PittsAM:nomsns}.
  We say that a morphism $α : I → I_α$ is a \emph{projection} if $I_α ⊆ I$,$α(i) = 0$
  for each $i ∈ I \backslash I_α$ and $α(i) = i$ for each $i ∈ I_α$.
  Injective morphisms, noted $h : I ↣ J$, are those verifying $h(i) ≠ 0$
  for all $i ∈ I$.
  A simple, but fundamental, remark is that any morphism $f : I → J$ has a
  unique decomposition into a projection map
  $α : I → I_α$ and an injective map $h : I_α ↣ J$.

  \begin{tikzpicture}[node distance=4\baselineskip]
    \node              (I)  {$I$};
    \node[below of=I]  (Ia) {$I_α$};
    \node[right of=Ia] (J)  {$J$};

    \draw[->] (I) to node[left] {$α$} (Ia);
    \draw[->] (I) to node[above right] {$f$} (J);
    \draw[to reversed->] (Ia) to node[below] {$h$} (J);
  \end{tikzpicture}
\end{definition}

\begin{definition}
  We call $I$-element any tuple indexed by the subsets of $I$: $(u_J)_{J ⊆ I}$.
  An $I$-set is a set of $I$-elements.  For instance, the elements of a
  $\{i,j\}$-set are of the form $u = (u_∅,u_i,u_j,u_{i,j})$.
  Alternatively, such an element can be seen as a tuple $(u_α)$ indexed
  by the projections $α : I → I_α$.
  %
  If $a,b$ are $I$-elements and $j ∉ I$, we define the $(I,j)$-element
  $(a ,_j b)$ as $(a ,_j b)_J ≔ a_J$ if $j ∉ J$ and $(a ,_j b)_{J,j} ≔ b_J$.
  %
  Any $(I,i)$-element can be written $u = (u_J)_{J ⊆ \{I,i\}} = (u_J)_{J ⊆ I} ∪ (u_{J,i})_{J ⊆ I}$;
  We can therefore define the $I$-elements $u (i\,0) ≔ (u_J)_{J ⊆ I}$ and $u · i ≔ (u_{J,i})_{J ⊆ I}$.
  (Hence by definition $u = (u (i\,0) ,_i u · i)$.)
\end{definition}

\bigskip
A \emph{presheaf} $F$ on \pI{} is given by a family of sets $F(I)$ together
with restriction maps $F(I) → F(J)$, $u ↦ uf$ for $f : I → J$
satisfying $u1 = u$ and $(uf)g = u(fg)$. We refine this notion by requiring
two further conditions:
%
\begin{enumerate}
  \item for any $I ∈ \pI$, $F(I)$ is a $I$-set, and
  \item for any projection map $α : I → I_α$, the restriction
    map $F(I) → F(I_α)$, $u ↦ uα$ is the projection operation, \ie,
    $uα_J = u_J$ for any $J ⊆ I$.
\end{enumerate}
%
Seeing an $I$-element $u$ as a tuple indexed by projection maps
$α : I → I_α$, the second restriction can be written $(uα)_β = u_{αβ}$.

\bigskip
A context $Γ ⊢_I$ is interpreted as a presheaf on the slice category
$\pI^\opp/I$, \ie, by a family of $J$-sets $Γf$ for any map $f : I → J$
together with restriction maps $Γ f → Γ fg$, $ρ ↦ ρg$
for $g : J → K$ satisfying the conditions $ρ 1 = ρ$ and $(ρg)h = ρ(gh)$.
Furthermore the map $Γf → Γ(fα)$, $ρ ↦ ρα$ is the projection operation.

\medskip
A type $Γ ⊢_I A$ is interpreted as follows.
For each map $f : I → J$, and $ρ ∈ Γf$ we give a $J$-set $A(f,ρ)$
together with restriction maps $A(f,ρ) → A(fg,ρg)$, $u ↦ ug$ if $g : J → K$
satisfying $u1 = u$ and $(ug)h = u(gh)$ for any $h : K → L$.
Furthermore the map $A(f,ρ) → A(fα,ρα)$, $u ↦ uα$ is the projection operation,

\medskip
A term $Γ ⊢_I a : A$ is defined by giving a $J$-element $a(f,ρ) ∈ A(f,ρ)$
for each $f: I → J$ and $ρ ∈ Γf$, such that
$a(f,ρ)g = a(fg,ρg)$ for any $g : J → K$.

\medskip
If $Γ ⊢_I A$ we define the interpretation of $Γ,x:A ⊢_I$
by taking $⟨ρ,x=u⟩ : (Γ,x:A)f$ to mean $ρ ∈ Γf$ and $u ∈ A(f,ρ)$. The
restriction map is defined by $(ρ,x=u)g = (ρ g, x=ug)$.

\bigskip
The above refinement on presheaves is necessary for the interpretation
of some of our styntactic constructions.  Indeed, without this refinement,
it is not clear how to validate the equality
${{(\CTimes i {x:A} B[x])} \op i a = B[a]}$.

\bigskip
The semantics we define satisfies the substitution law that if $Γ,x:A ⊢_I B$
and $Γ ⊢_I a:A$ then for any $f : I → J$ and $ρ ∈ Γ f$ we have
$B[a](f,ρ) = B(f,(ρ,x=a(f,ρ)))$.
It also satisfies the substitution law on colors, \ie, if $Γ ⊢_I A$ and
$f : I → J$ then for any $g : J → K$ we have $Γ'g = Γ(fg)$,
where $Γ'$ is the result of perfoming the substitution $f$ in $Γ$, and if
$ρ ∈ Γfg$ we have $Af (g,ρ) = A(fg,ρ)$.
For establishing these properties, one way is to introduce an intermediate
system with explicit substitution laws, as in \cite{cwf}.

\bigskip
\begin{description}
  \item[\sc Pi.]
    Assume $f : I → J$ and $ρ ∈ Γf$. We define $((x:A) → B)(ρ,f)$ as a $J$-set.
    A ($J$-)element of $((x:A) → B)(f,ρ)$ is defined as a tuple $λ = (λ_α)$,
    where each $λ_α$ is a family of elements indexed by any injective map $g : J_α ↣ K$:
    $$λ_{α g} ∈ \prod_{u : A(fα g,ραg)} B(fαg,⟨ραg,x=u⟩)$$
    such that
    $\app{λ_{αg}}{u} h = \app{λ_{gh}}{uh}$ for $g : J ↣ K$ total and \emph{any} $h : K → L$.
    Since any map $J → K$ has an unique decomposition in a projection and an injective
    map, we can consider $λ_h$ for an arbitrary map $h : J → K$.
    Indeed, if $g : J → K$ is an arbitrary map, we define $λ g$ to be the tuple
    $(λ g_β)$ where $λ g_β$ is the family $λ g_{βh} = λ_{gβh}$.

    With such a definition, it is direct that we have $λα_{β} = λ_{αβ}$.

    This is similar to the usual interpretation of dependent product in presheaf models \cite{Hofmann,BCH}
    except that we have to present each element as a tuple, which it is in a natural way.


  \item[\sc Universe.]
    The universe $U$ is interpreted as a presheaf over \pI. An element $A$ of
    $U(I)$ is a tuple $(A_α)$ where each $A_α$ is a family of sets
    $A_{α f}$ for $f : I ↣ J$ \emph{total} together with restriction
    maps $A_{α f} → A_{α fg}$, $u ↦ ug$ for $f : I ↣ J$ total
    and $g : J → K$ arbitrary, such that $u1 = u$ and $(ug)h = u(gh)$.

    If $g : I → J$ is an arbitrary map, we define $Ag$ by taking $Ag_{βh}$
    to be the set $A_{gβh}$, together with restriction maps $Ag_{βh} → Ag_{βhl}$
    defined as the given maps $A_{gβh} → A_{gβhl}$.

    We can then check, as before, that we have $Aα_{β} = A_{αβ}$

    This is similar to the usual interpretation of universe in presheaf models \cite{Hofmann,BCH}
    except that we have to present each element as a tuple, which it is in a natural way.


  \item[\sc Out.]
    Assume $f : I → J$ assume $ρ ∈ Γf$.  We need to define the $J$-set $(P \op {i} a)(f,ρ)$.
    Let $j = \fresh J$ and $f' = (f,i=j) : I,i → J,j$ and $ι_i : I → I,i$,
    $ι_j : J → J,j$ the inclusions.
    We can consider the $J,j$-set $P(f',ρι_i)$, and $a(f,ρ)$ is a ($J$-)element of
    $P(i\,0)(f,ρ) = P((i\,0)f,ρ) = P(ι_i f\,ρι_j)(j\,0)$.
    We define $(P \op {i} a)(f,ρ)$ to be the set of $J$-elements $v$ such that
    $(a(f,ρ),_j v) ∈ P(ι_i f\,ρι_j)$. If $v$ is such an element and $g : J → K$
    and $k=\fresh K$, then $vg$ is defined by the equation
    $(a(f,ρ)g,_k vg) = (a(f,ρ)g,_k v) g'$ with $g' = (g,j=k)$.

  \item[\sc In-Pred.]
    Assume $f : I,i → J$, and $ρ ∈ Γ(ι_if)$.  We need to define the $J$-set
    $(\CTimes {x:A} i B)(f,ρ)$.
    Let $ι_i : I → I,i$ be the inclusion. There are two cases. If $f(i) = 0$
    then $(\CTimes {x:A} i B)(f,ρ)$ is defined to be the $J$-set $A(ι_i f)$.
    Otherwise, if $f(i) = j ∈ J$, then we define $(\CTimes {x:A} i B)(f,ρ)$ to
    be the $J$-set of $(u,_j v)$ where $u$ is a $J\backslash\{j\}$-element in
    $A(ι_i f(j\,0),ρ(j\,0))$ and $v$ is an element in
    $B(ι_i f(j\,0),(ρ(j\,0),x=u))$.
\end{description}

\begin{theorem}
  If $Γ ⊢_I a : A$, $f : I → J$, $ρ ∈ Γf$, then $a(f,ρ) ∈ A(f,ρ)$.
%  Furthermore $af(1,ρ) = a(f,ρ)$ (using the interpretation of
%  $Γf ⊢_J af : Af$).
\end{theorem}

\begin{theorem}
  If $Γ ⊢_I a : A$ and $Γ ⊢_I b : A$ with $a = b$, then
  $a(f,ρ) = b(f,ρ)$ for any $f : I → J$ and $ρ : Γf$.
  In particular,
  \begin{itemize}
    \item $\app{λt}{u}(f,ρ) = t[u](f,ρ)$,
 %     where $[u]$ is the map $Γ → Γ.A$, $[u]ρ ↦ ⟨ρ,uρ⟩$
    \item $({(\CTimes {x:A} i B)} \op {i} a)(f,ρ) = B(f,(\rho,x=a(f,\rho))) = B[a] (f,ρ)$
  \end{itemize}
\end{theorem}
\begin{proof}
  Let $f : I → J$, $j = \fresh J$, $g = (f,i=j): I,i → J,j$. We have
  We have
  \begin{align*}
    ({((x:A)\times_i B)} \op {i} a)(f,ρ)
    &= \left\{ v \mid (a(f,ρ) ,_j v) ∈ (\CTimes {x:A} i B)g \right\}
    \\
    &= \left\{ v \mid (a(f,ρ) ,_j v) ∈ \left\{ (u ,_j w) \mid u ∈ A(f,ρ), w ∈ B(f,(ρ,x=u)) \right\} \right\}
    \\
    &= \left\{ v \mid v ∈ B(f,(ρ,x=a(f,ρ)) \right\}
    \\
    &= \left\{ v \mid v ∈ B[a](f,ρ) \right\}
    \\
    &= B[a](f,ρ)
  \qedhere
  \end{align*}
\end{proof}

\section{Related Work}

\subsection{Our own line of work}
This work continues a line of work aiming at a smooth integration of
parametricity with dependent types
\citep{bernardy_parametricity_2010,bernardy_realizability_2011,bernardy_proofs_2012,bernardy_computational_2012,bernardy_type-theory_2013}. The present work offers two improvements:
1. a denotational semantics, and
2. a much simplified syntax, suitable as the basis of a proof assistant.

The simplification of syntax is allowed by foregoing the preservation
of functions by parametricity. We call preservation of functions by
parametricity the property that if $f$ were a function, then the
canonical proof that $f$ is parametric (denoted $f \param i$ here) is
also a function. To our knowledge, following \citet{reynolds_types_1983}, all parametric \emph{models} of parametricity (both syntactical and semantical ones) have this property.
However, having this property in the \emph{syntax} implies that
certain function arguments must be swapped when performing the
substitution of beta reduction, as identified by
\citet{bernardy_computational_2012}.  In the present system, the
parametric interpretation of functions is instead merely isomorphic to
a function, thanks to the {\sc In-Fun} rule (\fref{thm:iso-fun}). This
isomorphism (rather than equality) means on the one hand that the
swapping of arguments is handled by the usual rules of logic, instead
of special-purpose ones. On the other hand, obtaining the classical
parametric interpretation of types requires some purely mechanical
work by the user of the logic.

\subsection{Parametric Models of Type-Theory vs. Parametric Type-Theories}

Two pieces of work propose alternative parametric models of
type-theory
\citep{atkey_relationally_2014,krishnaswami_internalizing_2013}, but
do not integrate parametricity in the syntax of the calculus. This
means that, while certain consequences of parametricity can be made
available in the logic, via constants validated by the model,
parametricity itself is not available. In this paper, we not only
propose a parametric model, but also show how it can be used to
interpret parametricity straight up in the syntax of the type-theory.


\subsection{Various kinds of models}
Another characterising feature of proposals for parametricity is the
kind of model underlying the
semantics. \Citet{krishnaswami_internalizing_2013} propose a model
based on Q-PER. \Citet{atkey_relationally_2014} propose a model based
on reflexive graphs. The model that we use is based on cubes
(functions from subsets of colors). In
our 2012 work the cubes were reified as syntax in
an underlying calculus, while in the present work they refine a presheaf structure.

\subsection{Presheaf models}

The presheaf construction used in this paper follows a known template,
used for example by \citet{bezem2014model,DBLP:journals/corr/Pitts14}
to model univalence in type-theory.Not only both models use a
presheaf, but the underlying category is the same ($\pI$). This means
as all these models have an additional cubical structure.  We find
remarkable that cubical structures are useful for modeling both
parametricity and univalence. The present work further refines the
model by interpreting terms as $I$-elements, which is essential to
interpret our special-purpose pairing constructions.

\section{Future work and conclusion}
We have defined a new type-theory with internalised parametricity.
Thanks to our model construction, we have proved the consistency of
the system. The missing piece to construct a type-checker is a
decision algorithm for the conversion relation.  This checker could
then be used as a minimal proof assistant for a type-theory with
parametricity.

\bibliographystyle{abbrvnat}
\bibliography{PaperTools/bibtex/jp,tt}

\end{document}
